<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Carte capteurs: Référence du fichier main.c</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Généré par Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Page&nbsp;principale</span></a></li>
      <li><a href="pages.html"><span>Pages&nbsp;associées</span></a></li>
      <li><a href="classes.html"><span>Structures&nbsp;de&nbsp;données</span></a></li>
      <li class="current"><a href="files.html"><span>Fichiers</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Référence du fichier main.c</h1>Contient la fonction <a class="el" href="main_8c.html#840291bc02cba5474a4cb46a9b9566fe" title="VECTOR REMAPPING.">main()</a> du programme. <a href="#_details">Plus de détails...</a>
<p>
<code>#include &lt;timers.h&gt;</code><br>
<code>#include &lt;usart.h&gt;</code><br>
<code>#include &lt;delays.h&gt;</code><br>
<code>#include &lt;string.h&gt;</code><br>
<code>#include &quot;<a class="el" href="_generic_type_defs_8h.html">GenericTypeDefs.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="_compiler_8h.html">Compiler.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="usb__config_8h.html">usb_config.h</a>&quot;</code><br>
<code>#include &quot;./USB/usb_device.h&quot;</code><br>
<code>#include &quot;./USB/usb.h&quot;</code><br>
<code>#include &quot;./USB/usb_function_hid.h&quot;</code><br>
<code>#include &quot;<a class="el" href="_hardware_profile_8h.html">HardwareProfile.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="eeprom_8h.html">eeprom.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="rangefinder_8h.html">rangefinder.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="tor_8h.html">tor.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="_pc_interface_8h.html">PcInterface.h</a>&quot;</code><br>

<p>
<div class="dynheader">
Graphe des dépendances par inclusion de main.c:</div>
<div class="dynsection">
<p><center><img src="main_8c__incl.png" border="0" usemap="#main.c_map" alt=""></center>
<map name="main.c_map">
<area shape="rect" href="_generic_type_defs_8h.html" title="GenericTypeDefs.h" alt="" coords="177,237,340,267"><area shape="rect" href="_compiler_8h.html" title="Compiler.h" alt="" coords="521,237,620,267"><area shape="rect" href="usb__config_8h.html" title="usb_config.h" alt="" coords="883,83,997,112"><area shape="rect" href="_hardware_profile_8h.html" title="Définitions spécifiques au PIC utilisé, pour l&#39;USB et les LEDs notamment." alt="" coords="608,160,760,189"><area shape="rect" href="eeprom_8h.html" title="Fonctions de lecture et d&#39;écriture avec l&#39;EEPROM du PIC." alt="" coords="181,160,272,189"><area shape="rect" href="rangefinder_8h.html" title="Gère la télémétrie." alt="" coords="283,83,403,112"><area shape="rect" href="_pc_interface_8h.html" title="Fichier commun avec le programme hôte sur la carte mère (USB PC)." alt="" coords="397,160,533,189"><area shape="rect" href="tor_8h.html" title="Gère les capteurs de contact TOR." alt="" coords="659,83,712,112"></map>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Macros</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#e67a648431caa2ec7195221f2b8d6229">mLED_Both_Off</a>()&nbsp;&nbsp;&nbsp;{mLED_1_Off();mLED_2_Off();}</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#b5df00e3551e829a60428ebf67a47312">mLED_Both_On</a>()&nbsp;&nbsp;&nbsp;{mLED_1_On();mLED_2_On();}</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#70aacfac58a156dd6e65b13f75e57496">mLED_Only_1_On</a>()&nbsp;&nbsp;&nbsp;{mLED_1_On();mLED_2_Off();}</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#a36c2b39f7cd41729476b21894fbc019">mLED_Only_2_On</a>()&nbsp;&nbsp;&nbsp;{mLED_1_Off();mLED_2_On();}</td></tr>

<tr><td colspan="2"><br><h2>Fonctions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#42a6b0f3c41a4e5e1722aca3c3a4b4b5">BlinkUSBStatus</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PRIVATE PROTOTYPES.  <a href="#42a6b0f3c41a4e5e1722aca3c3a4b4b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#4f80a71f6079faf7617114a373a05017">InitializeSystem</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Centralise les routines d'initialisation.  <a href="#4f80a71f6079faf7617114a373a05017"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#ace5bc936ba3a482762863d6da13c941">ProcessIO</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fonction de traitement principale du programme.  <a href="#ace5bc936ba3a482762863d6da13c941"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#655d748c28aad5b529f5826b50fe1251">UserInit</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Routine d'initialisation utilisateur.  <a href="#655d748c28aad5b529f5826b50fe1251"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#6647fa4207d49c8ba30d1609d0554791">YourHighPriorityISRCode</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#8fc705d66a5ec3a6012cd0d4210ac8a9">YourLowPriorityISRCode</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#d3060f9b061e802bba79e880c4484505">ResetSource</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="main_8c.html#d3060f9b061e802bba79e880c4484505" title="ResetSource() permet de connaitre l&#39;origine du dernier reset tout en réinitialisant...">ResetSource()</a> permet de connaitre l'origine du dernier reset tout en réinitialisant correctement les registres pour le prochain reset.  <a href="#d3060f9b061e802bba79e880c4484505"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#840291bc02cba5474a4cb46a9b9566fe">main</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">VECTOR REMAPPING.  <a href="#840291bc02cba5474a4cb46a9b9566fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#24bc7f902cfd3ef505708c71099ca32a">USBCBSuspend</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call back that is invoked when a USB suspend is detected.  <a href="#24bc7f902cfd3ef505708c71099ca32a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#cb07fd7b59801b89093d5f5a375a1bb1">USBCBWakeFromSuspend</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is called when the USB interrupt bit is set In this example the interrupt is only used when the device goes to sleep when it receives a USB suspend command.  <a href="#cb07fd7b59801b89093d5f5a375a1bb1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#d39fa1008b49fb91555086e40710d573">USBCB_SOF_Handler</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The USB host sends out a SOF packet to full-speed devices every 1 ms.  <a href="#d39fa1008b49fb91555086e40710d573"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#e6717d77804b36ca26a975fd0bee6f01">USBCBErrorHandler</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The purpose of this callback is mainly for debugging during development.  <a href="#e6717d77804b36ca26a975fd0bee6f01"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#a1730f3cc119bd8eb04d9b55ebed56e6">USBCBCheckOtherReq</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When SETUP packets arrive from the host, some firmware must process the request and respond appropriately to fulfill the request.  <a href="#a1730f3cc119bd8eb04d9b55ebed56e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#85c176c4ca674eb30b43b414f6a66260">USBCBStdSetDscHandler</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="usb__device_8h.html#85c176c4ca674eb30b43b414f6a66260" title="The USBCBStdSetDscHandler() callback function is called when a SETUP, bRequest: SET_DESCRIPTOR...">USBCBStdSetDscHandler()</a> callback function is called when a SETUP, bRequest: SET_DESCRIPTOR request arrives.  <a href="#85c176c4ca674eb30b43b414f6a66260"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#e69da16b1f966a62cdd1831df5561cbf">USBCBInitEP</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is called when the device becomes initialized, which occurs after the host sends a SET_CONFIGURATION (wValue not = 0) request.  <a href="#e69da16b1f966a62cdd1831df5561cbf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#0349054fd83e147e1a88e375748e8caf">USBCBSendResume</a> (void)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a> [64]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">INCLUDES.  <a href="#6d79583150d44af3d64e01a6c4e3abe0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a> [64]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">USB_HANDLE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#fdba80f833058ed3f3776089fe23821c">USBOutHandle</a> = 0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">USB_HANDLE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#92264d29f54b522e280bcad0d603e64a">USBInHandle</a> = 0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="_generic_type_defs_8h.html#54d65c7fa62e62c9754371e42f5111b9">BOOL</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#663117df30d6ab9eef2e1280f4956ec3">blinkStatusValid</a> = TRUE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#d1e58a5c30aa93b2b02ed582dc185fa5">resetSource</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Description détaillée</h2>
Contient la fonction <a class="el" href="main_8c.html#840291bc02cba5474a4cb46a9b9566fe" title="VECTOR REMAPPING.">main()</a> du programme. 
<p>
<hr><h2>Documentation des macros</h2>
<a class="anchor" name="e67a648431caa2ec7195221f2b8d6229"></a><!-- doxytag: member="main.c::mLED_Both_Off" ref="e67a648431caa2ec7195221f2b8d6229" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mLED_Both_Off          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;{mLED_1_Off();mLED_2_Off();}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b5df00e3551e829a60428ebf67a47312"></a><!-- doxytag: member="main.c::mLED_Both_On" ref="b5df00e3551e829a60428ebf67a47312" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mLED_Both_On          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;{mLED_1_On();mLED_2_On();}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="70aacfac58a156dd6e65b13f75e57496"></a><!-- doxytag: member="main.c::mLED_Only_1_On" ref="70aacfac58a156dd6e65b13f75e57496" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mLED_Only_1_On          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;{mLED_1_On();mLED_2_Off();}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a36c2b39f7cd41729476b21894fbc019"></a><!-- doxytag: member="main.c::mLED_Only_2_On" ref="a36c2b39f7cd41729476b21894fbc019" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mLED_Only_2_On          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;{mLED_1_Off();mLED_2_On();}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Documentation des fonctions</h2>
<a class="anchor" name="42a6b0f3c41a4e5e1722aca3c3a4b4b5"></a><!-- doxytag: member="main.c::BlinkUSBStatus" ref="42a6b0f3c41a4e5e1722aca3c3a4b4b5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BlinkUSBStatus           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
PRIVATE PROTOTYPES. 
<p>
Gestion des LEDs selon l'état du périphérique USB.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Les macros mLED se trouve dans <a class="el" href="_hardware_profile_8h.html" title="Définitions spécifiques au PIC utilisé, pour l&#39;USB et les LEDs notamment.">HardwareProfile.h</a> <br>
 USBDeviceState est déclarée et mis à jour dans <a class="el" href="usb__device_8c.html">usb_device.c</a>. </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00606"></a>00606 {
<a name="l00607"></a>00607     <span class="keyword">static</span> <a class="code" href="_generic_type_defs_8h.html#2b0e863dadf920709ec53d9088ee7c91">WORD</a> led_count=0;
<a name="l00608"></a>00608     
<a name="l00609"></a>00609     <span class="keywordflow">if</span>(led_count == 0)led_count = 10000U;
<a name="l00610"></a>00610     led_count--;
<a name="l00611"></a>00611 
<a name="l00612"></a>00612 <span class="preprocessor">    #define mLED_Both_Off()         {mLED_1_Off();mLED_2_Off();}</span>
<a name="l00613"></a>00613 <span class="preprocessor"></span><span class="preprocessor">    #define mLED_Both_On()          {mLED_1_On();mLED_2_On();}</span>
<a name="l00614"></a>00614 <span class="preprocessor"></span><span class="preprocessor">    #define mLED_Only_1_On()        {mLED_1_On();mLED_2_Off();}</span>
<a name="l00615"></a>00615 <span class="preprocessor"></span><span class="preprocessor">    #define mLED_Only_2_On()        {mLED_1_Off();mLED_2_On();}</span>
<a name="l00616"></a>00616 <span class="preprocessor"></span>
<a name="l00617"></a>00617     <span class="keywordflow">if</span>(<a class="code" href="usb__hal__pic18_8h.html#692643ef2e9ce498623a4f83b60952ce">USBSuspendControl</a> == 1)
<a name="l00618"></a>00618     {
<a name="l00619"></a>00619         <span class="keywordflow">if</span>(led_count==0)
<a name="l00620"></a>00620         {
<a name="l00621"></a>00621             <a class="code" href="_hardware_profile_8h.html#e9c56afc3ce3e0237f8bd50a58211935">mLED_1_Toggle</a>();
<a name="l00622"></a>00622             <span class="keywordflow">if</span>(<a class="code" href="_hardware_profile_8h.html#0ab4d6b68d300cfb30fe4fd70104c6fc">mGetLED_1</a>())
<a name="l00623"></a>00623             {
<a name="l00624"></a>00624                 <a class="code" href="_hardware_profile_8h.html#22f2591efef8efbc59ca78f23592628a">mLED_2_On</a>();
<a name="l00625"></a>00625             }
<a name="l00626"></a>00626             <span class="keywordflow">else</span>
<a name="l00627"></a>00627             {
<a name="l00628"></a>00628                 <a class="code" href="_hardware_profile_8h.html#a677cbc2658fcdcaa6c5205296fdb069">mLED_2_Off</a>();
<a name="l00629"></a>00629             }
<a name="l00630"></a>00630         }<span class="comment">//end if</span>
<a name="l00631"></a>00631     }
<a name="l00632"></a>00632     <span class="keywordflow">else</span>
<a name="l00633"></a>00633     {
<a name="l00634"></a>00634         <span class="keywordflow">if</span>(<a class="code" href="usb__device_8h.html#c6e6520c8c73c4456ea7194acff5bb71" title="EXTERNS.">USBDeviceState</a> == <a class="code" href="usb__device_8h.html#f93e6ca83071e0b9716689d05a26b0e0">DETACHED_STATE</a>)
<a name="l00635"></a>00635         {
<a name="l00636"></a>00636             <a class="code" href="main_8c.html#e67a648431caa2ec7195221f2b8d6229">mLED_Both_Off</a>();
<a name="l00637"></a>00637         }
<a name="l00638"></a>00638         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="usb__device_8h.html#c6e6520c8c73c4456ea7194acff5bb71" title="EXTERNS.">USBDeviceState</a> == <a class="code" href="usb__device_8h.html#485fb1d1dd0df89593f2dfdfcd4fcad1">ATTACHED_STATE</a>)
<a name="l00639"></a>00639         {
<a name="l00640"></a>00640             <a class="code" href="main_8c.html#b5df00e3551e829a60428ebf67a47312">mLED_Both_On</a>();
<a name="l00641"></a>00641         }
<a name="l00642"></a>00642         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="usb__device_8h.html#c6e6520c8c73c4456ea7194acff5bb71" title="EXTERNS.">USBDeviceState</a> == <a class="code" href="usb__device_8h.html#8dab51c2d5fd7f95bba6c9c10106b989">POWERED_STATE</a>)
<a name="l00643"></a>00643         {
<a name="l00644"></a>00644             <a class="code" href="main_8c.html#70aacfac58a156dd6e65b13f75e57496">mLED_Only_1_On</a>();
<a name="l00645"></a>00645         }
<a name="l00646"></a>00646         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="usb__device_8h.html#c6e6520c8c73c4456ea7194acff5bb71" title="EXTERNS.">USBDeviceState</a> == <a class="code" href="usb__device_8h.html#f93d7c80faa6ebd086460cde2d5dd27e">DEFAULT_STATE</a>)
<a name="l00647"></a>00647         {
<a name="l00648"></a>00648             <a class="code" href="main_8c.html#a36c2b39f7cd41729476b21894fbc019">mLED_Only_2_On</a>();
<a name="l00649"></a>00649         }
<a name="l00650"></a>00650         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="usb__device_8h.html#c6e6520c8c73c4456ea7194acff5bb71" title="EXTERNS.">USBDeviceState</a> == <a class="code" href="usb__device_8h.html#6bcec49c4751b6e53d47835eeca5651a">ADDRESS_STATE</a>)
<a name="l00651"></a>00651         {
<a name="l00652"></a>00652             <span class="keywordflow">if</span>(led_count == 0)
<a name="l00653"></a>00653             {
<a name="l00654"></a>00654                 <a class="code" href="_hardware_profile_8h.html#e9c56afc3ce3e0237f8bd50a58211935">mLED_1_Toggle</a>();
<a name="l00655"></a>00655                 <a class="code" href="_hardware_profile_8h.html#a677cbc2658fcdcaa6c5205296fdb069">mLED_2_Off</a>();
<a name="l00656"></a>00656             }<span class="comment">//end if</span>
<a name="l00657"></a>00657         }
<a name="l00658"></a>00658         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="usb__device_8h.html#c6e6520c8c73c4456ea7194acff5bb71" title="EXTERNS.">USBDeviceState</a> == <a class="code" href="usb__device_8h.html#2aba92e0aaf8ccae5d19fa4de46d0c8f">CONFIGURED_STATE</a>)
<a name="l00659"></a>00659         {
<a name="l00660"></a>00660             <span class="keywordflow">if</span>(led_count==0)
<a name="l00661"></a>00661             {
<a name="l00662"></a>00662                 <a class="code" href="_hardware_profile_8h.html#e9c56afc3ce3e0237f8bd50a58211935">mLED_1_Toggle</a>();
<a name="l00663"></a>00663                 <span class="keywordflow">if</span>(<a class="code" href="_hardware_profile_8h.html#0ab4d6b68d300cfb30fe4fd70104c6fc">mGetLED_1</a>())
<a name="l00664"></a>00664                 {
<a name="l00665"></a>00665                     <a class="code" href="_hardware_profile_8h.html#a677cbc2658fcdcaa6c5205296fdb069">mLED_2_Off</a>();
<a name="l00666"></a>00666                 }
<a name="l00667"></a>00667                 <span class="keywordflow">else</span>
<a name="l00668"></a>00668                 {
<a name="l00669"></a>00669                     <a class="code" href="_hardware_profile_8h.html#22f2591efef8efbc59ca78f23592628a">mLED_2_On</a>();
<a name="l00670"></a>00670                 }
<a name="l00671"></a>00671             }<span class="comment">//end if</span>
<a name="l00672"></a>00672         }<span class="comment">//end if(...)</span>
<a name="l00673"></a>00673     }<span class="comment">//end if(UCONbits.SUSPND...)</span>
<a name="l00674"></a>00674 
<a name="l00675"></a>00675 }<span class="comment">//end BlinkUSBStatus</span>
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4f80a71f6079faf7617114a373a05017"></a><!-- doxytag: member="main.c::InitializeSystem" ref="4f80a71f6079faf7617114a373a05017" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void InitializeSystem           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Centralise les routines d'initialisation. 
<p>
Toutes les routines d'initialisation USB sont appelées de cette fonction. La routine d'initialisation utilisateur doit également être appelée d'ici. <dl class="note" compact><dt><b>Note:</b></dt><dd>Cette fonction n'a pas à être modifiée, voir la fonction <a class="el" href="main_8c.html#655d748c28aad5b529f5826b50fe1251" title="Routine d&#39;initialisation utilisateur.">UserInit()</a>. </dd></dl>
<dl class="see" compact><dt><b>Voir également:</b></dt><dd><a class="el" href="usb__device_8h.html#16da2c36e4eb6a018808f99f291433ca" title="DECLARATIONS.">USBDeviceInit()</a> et <a class="el" href="main_8c.html#655d748c28aad5b529f5826b50fe1251" title="Routine d&#39;initialisation utilisateur.">UserInit()</a>. </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00279"></a>00279 {
<a name="l00280"></a>00280     ADCON1 |= 0x0F;                 <span class="comment">// Default all pins to digital</span>
<a name="l00281"></a>00281     
<a name="l00282"></a>00282 <span class="comment">//      The USB specifications require that USB peripheral devices must never source</span>
<a name="l00283"></a>00283 <span class="comment">//      current onto the Vbus pin.  Additionally, USB peripherals should not source</span>
<a name="l00284"></a>00284 <span class="comment">//      current on D+ or D- when the host/hub is not actively powering the Vbus line.</span>
<a name="l00285"></a>00285 <span class="comment">//      When designing a self powered (as opposed to bus powered) USB peripheral</span>
<a name="l00286"></a>00286 <span class="comment">//      device, the firmware should make sure not to turn on the USB module and D+</span>
<a name="l00287"></a>00287 <span class="comment">//      or D- pull up resistor unless Vbus is actively powered.  Therefore, the</span>
<a name="l00288"></a>00288 <span class="comment">//      firmware needs some means to detect when Vbus is being powered by the host.</span>
<a name="l00289"></a>00289 <span class="comment">//      A 5V tolerant I/O pin can be connected to Vbus (through a resistor), and</span>
<a name="l00290"></a>00290 <span class="comment">//      can be used to detect when Vbus is high (host actively powering), or low</span>
<a name="l00291"></a>00291 <span class="comment">//      (host is shut down or otherwise not supplying power).  The USB firmware</span>
<a name="l00292"></a>00292 <span class="comment">//      can then periodically poll this I/O pin to know when it is okay to turn on</span>
<a name="l00293"></a>00293 <span class="comment">//      the USB module/D+/D- pull up resistor.  When designing a purely bus powered</span>
<a name="l00294"></a>00294 <span class="comment">//      peripheral device, it is not possible to source current on D+ or D- when the</span>
<a name="l00295"></a>00295 <span class="comment">//      host is not actively providing power on Vbus. Therefore, implementing this</span>
<a name="l00296"></a>00296 <span class="comment">//      bus sense feature is optional.  This firmware can be made to use this bus</span>
<a name="l00297"></a>00297 <span class="comment">//      sense feature by making sure "USE_USB_BUS_SENSE_IO" has been defined in the</span>
<a name="l00298"></a>00298 <span class="comment">//      HardwareProfile.h file.    </span>
<a name="l00299"></a>00299 <span class="preprocessor">    #if defined(USE_USB_BUS_SENSE_IO)</span>
<a name="l00300"></a>00300 <span class="preprocessor"></span>    <a class="code" href="_hardware_profile_8h.html#232aeea381ca80764b4a70a64b0a658d">tris_usb_bus_sense</a> = <a class="code" href="_hardware_profile_8h.html#1a806e0533aa476bb6e62b7d22c93572" title="TRIS.">INPUT_PIN</a>; <span class="comment">// See HardwareProfile.h</span>
<a name="l00301"></a>00301 <span class="preprocessor">    #endif</span>
<a name="l00302"></a>00302 <span class="preprocessor"></span>    
<a name="l00303"></a>00303 <span class="comment">//      If the host PC sends a GetStatus (device) request, the firmware must respond</span>
<a name="l00304"></a>00304 <span class="comment">//      and let the host know if the USB peripheral device is currently bus powered</span>
<a name="l00305"></a>00305 <span class="comment">//      or self powered.  See chapter 9 in the official USB specifications for details</span>
<a name="l00306"></a>00306 <span class="comment">//      regarding this request.  If the peripheral device is capable of being both</span>
<a name="l00307"></a>00307 <span class="comment">//      self and bus powered, it should not return a hard coded value for this request.</span>
<a name="l00308"></a>00308 <span class="comment">//      Instead, firmware should check if it is currently self or bus powered, and</span>
<a name="l00309"></a>00309 <span class="comment">//      respond accordingly.  If the hardware has been configured like demonstrated</span>
<a name="l00310"></a>00310 <span class="comment">//      on the PICDEM FS USB Demo Board, an I/O pin can be polled to determine the</span>
<a name="l00311"></a>00311 <span class="comment">//      currently selected power source.  On the PICDEM FS USB Demo Board, "RA2" </span>
<a name="l00312"></a>00312 <span class="comment">//      is used for     this purpose.  If using this feature, make sure "USE_SELF_POWER_SENSE_IO"</span>
<a name="l00313"></a>00313 <span class="comment">//      has been defined in HardwareProfile.h, and that an appropriate I/O pin has been mapped</span>
<a name="l00314"></a>00314 <span class="comment">//      to it in HardwareProfile.h.</span>
<a name="l00315"></a>00315 <span class="preprocessor">    #if defined(USE_SELF_POWER_SENSE_IO)</span>
<a name="l00316"></a>00316 <span class="preprocessor"></span>    <a class="code" href="_hardware_profile_8h.html#ba35cc821d7d3d1c490ce9778e80f363">tris_self_power</a> = <a class="code" href="_hardware_profile_8h.html#1a806e0533aa476bb6e62b7d22c93572" title="TRIS.">INPUT_PIN</a>;        <span class="comment">// See HardwareProfile.h</span>
<a name="l00317"></a>00317 <span class="preprocessor">    #endif</span>
<a name="l00318"></a>00318 <span class="preprocessor"></span>    
<a name="l00319"></a>00319     <a class="code" href="usb__device_8h.html#16da2c36e4eb6a018808f99f291433ca" title="DECLARATIONS.">USBDeviceInit</a>();    <span class="comment">//usb_device.c.  Initializes USB module SFRs and firmware</span>
<a name="l00320"></a>00320                                         <span class="comment">//variables to known states.</span>
<a name="l00321"></a>00321     <a class="code" href="main_8c.html#655d748c28aad5b529f5826b50fe1251" title="Routine d&amp;#39;initialisation utilisateur.">UserInit</a>();
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 }<span class="comment">//end InitializeSystem</span>
</pre></div>
<p>

<p>
<div class="dynheader">
Voici le graphe d'appel pour cette fonction :</div>
<div class="dynsection">
<p><center><img src="main_8c_4f80a71f6079faf7617114a373a05017_cgraph.png" border="0" usemap="#main_8c_4f80a71f6079faf7617114a373a05017_cgraph_map" alt=""></center>
<map name="main_8c_4f80a71f6079faf7617114a373a05017_cgraph_map">
<area shape="rect" href="usb__device_8h.html#16da2c36e4eb6a018808f99f291433ca" title="DECLARATIONS." alt="" coords="191,5,316,35"><area shape="rect" href="main_8c.html#655d748c28aad5b529f5826b50fe1251" title="Routine d&#39;initialisation utilisateur." alt="" coords="215,59,292,88"><area shape="rect" href="usb__device_8h.html#42d85f637ff9d3615ca3090303008adc" title="USBClearInterruptFlag" alt="" coords="367,5,551,35"><area shape="rect" href="main_8c.html#d3060f9b061e802bba79e880c4484505" title="ResetSource() permet de connaitre l&#39;origine du dernier reset tout en réinitialisant..." alt="" coords="401,59,516,88"></map>
</div>

</div>
</div><p>
<a class="anchor" name="840291bc02cba5474a4cb46a9b9566fe"></a><!-- doxytag: member="main.c::main" ref="840291bc02cba5474a4cb46a9b9566fe" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
VECTOR REMAPPING. 
<p>
DECLARATIONS Main program entry point. <div class="fragment"><pre class="fragment"><a name="l00235"></a>00235 {
<a name="l00236"></a>00236 <span class="comment">//    //This can be used for user entry into the bootloader  </span>
<a name="l00237"></a>00237 <span class="comment">//    #if defined(__C30__) </span>
<a name="l00238"></a>00238 <span class="comment">//        mInitSwitch2();</span>
<a name="l00239"></a>00239 <span class="comment">//        if(sw2 == 0)</span>
<a name="l00240"></a>00240 <span class="comment">//        {</span>
<a name="l00241"></a>00241 <span class="comment">//            EnterBootloader();</span>
<a name="l00242"></a>00242 <span class="comment">//        }</span>
<a name="l00243"></a>00243 <span class="comment">//    #endif</span>
<a name="l00244"></a>00244 
<a name="l00245"></a>00245     <a class="code" href="main_8c.html#4f80a71f6079faf7617114a373a05017" title="Centralise les routines d&amp;#39;initialisation.">InitializeSystem</a>();
<a name="l00246"></a>00246 
<a name="l00247"></a>00247     <span class="keywordflow">while</span>(1)
<a name="l00248"></a>00248     {
<a name="l00249"></a>00249                 <span class="comment">// Check bus status and service USB interrupts.</span>
<a name="l00250"></a>00250         <a class="code" href="usb__device_8h.html#f35807553af66eab5b5d459fa13b274e" title="PUBLIC PROTOTYPES.">USBDeviceTasks</a>(); <span class="comment">// Interrupt or polling method.  If using polling, must call</span>
<a name="l00251"></a>00251                                           <span class="comment">// this function periodically.  This function will take care</span>
<a name="l00252"></a>00252                                           <span class="comment">// of processing and responding to SETUP transactions </span>
<a name="l00253"></a>00253                                           <span class="comment">// (such as during the enumeration process when you first</span>
<a name="l00254"></a>00254                                           <span class="comment">// plug in).  USB hosts require that USB devices should accept</span>
<a name="l00255"></a>00255                                           <span class="comment">// and process SETUP packets in a timely fashion.  Therefore,</span>
<a name="l00256"></a>00256                                           <span class="comment">// when using polling, this function should be called </span>
<a name="l00257"></a>00257                                           <span class="comment">// frequently (such as once about every 100 microseconds) at any</span>
<a name="l00258"></a>00258                                           <span class="comment">// time that a SETUP packet might reasonably be expected to</span>
<a name="l00259"></a>00259                                           <span class="comment">// be sent by the host to your device.  In most cases, the</span>
<a name="l00260"></a>00260                                           <span class="comment">// USBDeviceTasks() function does not take very long to</span>
<a name="l00261"></a>00261                                           <span class="comment">// execute (~50 instruction cycles) before it returns.</span>
<a name="l00262"></a>00262                                   
<a name="l00263"></a>00263 
<a name="l00264"></a>00264                 <span class="comment">// Application-specific tasks.</span>
<a name="l00265"></a>00265                 <span class="comment">// Application related code may be added here, or in the ProcessIO() function.</span>
<a name="l00266"></a>00266         <a class="code" href="main_8c.html#ace5bc936ba3a482762863d6da13c941" title="Fonction de traitement principale du programme.">ProcessIO</a>();        
<a name="l00267"></a>00267     }<span class="comment">//end while</span>
<a name="l00268"></a>00268 }<span class="comment">//end main</span>
</pre></div>
<p>

<p>
<div class="dynheader">
Voici le graphe d'appel pour cette fonction :</div>
<div class="dynsection">
<p><center><img src="main_8c_840291bc02cba5474a4cb46a9b9566fe_cgraph.png" border="0" usemap="#main_8c_840291bc02cba5474a4cb46a9b9566fe_cgraph_map" alt=""></center>
<map name="main_8c_840291bc02cba5474a4cb46a9b9566fe_cgraph_map">
<area shape="rect" href="main_8c.html#4f80a71f6079faf7617114a373a05017" title="Centralise les routines d&#39;initialisation." alt="" coords="116,341,249,371"><area shape="rect" href="main_8c.html#ace5bc936ba3a482762863d6da13c941" title="Fonction de traitement principale du programme." alt="" coords="133,160,232,189"><area shape="rect" href="usb__device_8h.html#f35807553af66eab5b5d459fa13b274e" title="PUBLIC PROTOTYPES." alt="" coords="109,792,256,821"><area shape="rect" href="usb__device_8h.html#16da2c36e4eb6a018808f99f291433ca" title="DECLARATIONS." alt="" coords="367,368,492,397"><area shape="rect" href="main_8c.html#655d748c28aad5b529f5826b50fe1251" title="Routine d&#39;initialisation utilisateur." alt="" coords="391,315,468,344"><area shape="rect" href="usb__device_8h.html#42d85f637ff9d3615ca3090303008adc" title="USBClearInterruptFlag" alt="" coords="623,739,807,768"><area shape="rect" href="main_8c.html#d3060f9b061e802bba79e880c4484505" title="ResetSource() permet de connaitre l&#39;origine du dernier reset tout en réinitialisant..." alt="" coords="657,315,772,344"><area shape="rect" href="main_8c.html#42a6b0f3c41a4e5e1722aca3c3a4b4b5" title="PRIVATE PROTOTYPES." alt="" coords="363,56,496,85"><area shape="rect" href="rangefinder_8c.html#6af556b86bdcad857be2fbe2599bcde4" title="Fonction de calibration semi&#45;automatique d&#39;un télémètre." alt="" coords="388,160,471,189"><area shape="rect" href="rangefinder_8c.html#905b1f6dd68931ac8abb5db4dac699bd" title="Donne la distance mesurée pour un télémètre." alt="" coords="643,31,787,60"><area shape="rect" href="rangefinder_8c.html#7782486c96b2ff62dab69f99636a861e" title="Mesure une distance sur un télémètre." alt="" coords="641,115,788,144"><area shape="rect" href="eeprom_8c.html#23c79775828a6c484c66ba66b42ca847" title="Lit dans l&#39;EEPROM du PIC." alt="" coords="651,180,779,209"><area shape="rect" href="eeprom_8c.html#fd48dcf153304aa7a2726ca1b717ab14" title="Ecrit dans l&#39;EEPROM du PIC." alt="" coords="649,256,780,285"><area shape="rect" href="rangefinder_8c.html#438675a7ef66fd328e56e27a7bff362f" title="Sélection d&#39;un télémètre." alt="" coords="915,141,1067,171"><area shape="rect" href="rangefinder_8c.html#6d00149bf7ccb02aed245c211ce25826" title="Envoie une impulsion ultrason." alt="" coords="943,88,1039,117"><area shape="rect" href="usb__otg_8h.html#c5d1852c92a2364bf541966638962f42" title="USB_OTGEventHandler" alt="" coords="333,952,525,981"><area shape="rect" href="usb__device_8h.html#d39fa1008b49fb91555086e40710d573" title="The USB host sends out a SOF packet to full&#45;speed devices every 1 ms." alt="" coords="337,1005,521,1035"><area shape="rect" href="usb__device_8h.html#e6717d77804b36ca26a975fd0bee6f01" title="The purpose of this callback is mainly for debugging during development." alt="" coords="344,1059,515,1088"><area shape="rect" href="usb__device_8h.html#e5d35bef641e59de9a7279d639cc10b6" title="USBCtrlEPService" alt="" coords="352,899,507,928"><area shape="rect" href="usb__otg_8h.html#d078cd43132c6251de3865b19b8de4cb" title="USBOTGDisableHnp" alt="" coords="1428,925,1599,955"><area shape="rect" href="usb__otg_8h.html#0e4aa57c5361e842d6ff6892aab573b6" title="USBOTGClearSRPReady" alt="" coords="327,1163,532,1192"><area shape="rect" href="usb__otg_8h.html#d4bbe76141dea5928c75ce40938717e1" title="USBOTGClearSRPTimeOutFlag" alt="" coords="304,1216,555,1245"><area shape="rect" href="usb__otg_8h.html#f436961125c7e07df2081b53e4b37001" title="USBOTGDeactivateHnp" alt="" coords="333,1269,525,1299"><area shape="rect" href="usb__otg_8h.html#78ca11f637dbda5615015004b1af7a43" title="USBOTGGetSRPTimeOutFlag" alt="" coords="312,472,547,501"><area shape="rect" href="usb__otg_8h.html#1821d7229191e748ee716d497b14e5a2" title="USBOTGInitialize" alt="" coords="356,525,503,555"><area shape="rect" href="usb__otg_8h.html#f06c63d6f822660c4a2a3a52c29fd257" title="USBOTGIsSRPTimeOutExpired" alt="" coords="305,579,553,608"><area shape="rect" href="usb__otg_8h.html#6b7e526fa731f878145d8a05ac1afc02" title="USBOTGSelectRole" alt="" coords="348,632,511,661"><area shape="rect" href="usb__otg_8h.html#074a26ffca9ba1473076efdb826d1771" title="USBOTGSRPIsReady" alt="" coords="340,685,519,715"><area shape="rect" href="usb__device_8h.html#f7fca92a339183ae8f268bb8c3ca4e7e" title="USBStallHandler" alt="" coords="360,739,499,768"><area shape="rect" href="usb__device_8h.html#1e0966febda8e01d2e4e58ceb42dd46a" title="USBSuspend" alt="" coords="371,792,488,821"><area shape="rect" href="usb__device_8h.html#9104bea8c7f5045558f6cc5721e7455f" title="USBWakeFromSuspend" alt="" coords="329,845,529,875"><area shape="rect" href="usb__device_8h.html#8bfda535b2c9273a24983c1799f3fb42" title="USBCtrlTrfInHandler" alt="" coords="631,953,799,983"><area shape="rect" href="usb__device_8h.html#d30a9aeba644af617b04c45333fc5125" title="USBCtrlTrfOutHandler" alt="" coords="625,1007,804,1036"><area shape="rect" href="usb__device_8h.html#4fd82120d0ce7ac5df27574b2fcd2b8f" title="USBCtrlTrfSetupHandler" alt="" coords="616,899,813,928"><area shape="rect" href="usb__device_8h.html#6dde221e5c27eb18f62335810c830630" title="USBCtrlTrfTxService" alt="" coords="1180,1008,1351,1037"><area shape="rect" href="usb__device_8h.html#5fff309db0c489c108b02e5b0c665f3a" title="USBPrepareForNextSetupTrf" alt="" coords="875,1005,1107,1035"><area shape="rect" href="usb__device_8h.html#8cc0ab9c4555c92370fe9d0ffb0685c7" title="USBCtrlTrfRxService" alt="" coords="905,1059,1076,1088"><area shape="rect" href="usb__device_8h.html#a1730f3cc119bd8eb04d9b55ebed56e6" title="When SETUP packets arrive from the host, some firmware must process the request and..." alt="" coords="895,741,1087,771"><area shape="rect" href="usb__device_8h.html#6d12a2e760ab2e6dc50498a76e3cfcc4" title="USBCheckStdRequest" alt="" coords="899,848,1083,877"><area shape="rect" href="usb__device_8h.html#0913bb6b0a880a6e29d58c88c3c1e730" title="USBCtrlEPServiceComplete" alt="" coords="879,901,1103,931"><area shape="rect" href="usb__function__hid_8h.html#5e0b02add954ecf19bcdef679a58988b" title="Section: PUBLIC PROTOTYPES." alt="" coords="1172,688,1359,717"><area shape="rect" href="usb__function__hid_8c.html#fb60fd12cb265cc70fd3b2d11802cd09" title="PRIVATE PROTOTYPES." alt="" coords="1424,688,1603,717"><area shape="rect" href="usb__device_8h.html#85c176c4ca674eb30b43b414f6a66260" title="The USBCBStdSetDscHandler() callback function is called when a SETUP, bRequest: SET_DESCRIPTOR..." alt="" coords="1160,955,1371,984"><area shape="rect" href="usb__device_8h.html#109b75c6ceba7a1ac93ac8653dae6405" title="USBStdFeatureReqHandler" alt="" coords="1156,741,1375,771"><area shape="rect" href="usb__device_8h.html#05d1ee4a1e4a8c8af6fb4816eba0a591" title="USBStdGetDscHandler" alt="" coords="1172,795,1359,824"><area shape="rect" href="usb__device_8h.html#07599ba7765be64baabac4e86cdb5358" title="USBStdGetStatusHandler" alt="" coords="1164,848,1367,877"><area shape="rect" href="usb__device_8h.html#23b85d487e9d3b37a4580138baf6b097" title="USBStdSetCfgHandler" alt="" coords="1173,901,1357,931"><area shape="rect" href="usb__device_8h.html#24bc7f902cfd3ef505708c71099ca32a" title="Section: CALLBACKS." alt="" coords="644,792,785,821"><area shape="rect" href="usb__device_8h.html#cb07fd7b59801b89093d5f5a375a1bb1" title="This function is called when the USB interrupt bit is set In this example the interrupt..." alt="" coords="604,845,825,875"></map>
</div>

</div>
</div><p>
<a class="anchor" name="ace5bc936ba3a482762863d6da13c941"></a><!-- doxytag: member="main.c::ProcessIO" ref="ace5bc936ba3a482762863d6da13c941" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProcessIO           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fonction de traitement principale du programme. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00378"></a>00378                      {   
<a name="l00379"></a>00379         <span class="keyword">static</span> <span class="keywordtype">char</span> rangefinder = 0;
<a name="l00380"></a>00380         <span class="keyword">static</span> <span class="keywordtype">char</span> mode = <a class="code" href="rangefinder_8h.html#d5357a5cc43a498c85b113357923f8aa">MODE_MEASURE</a>;
<a name="l00381"></a>00381         <span class="keyword">static</span> <span class="keywordtype">char</span> status;
<a name="l00382"></a>00382         <span class="keyword">static</span> <a class="code" href="_generic_type_defs_8h.html#54d65c7fa62e62c9754371e42f5111b9">BOOL</a> skipMeas;
<a name="l00383"></a>00383 
<a name="l00384"></a>00384         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> eeprom;
<a name="l00385"></a>00385         <span class="keywordtype">char</span> i;
<a name="l00386"></a>00386         <span class="keywordtype">long</span> dist;
<a name="l00387"></a>00387 
<a name="l00388"></a>00388     <span class="comment">//Blink the LEDs according to the USB device status</span>
<a name="l00389"></a>00389     <span class="keywordflow">if</span>(<a class="code" href="main_8c.html#663117df30d6ab9eef2e1280f4956ec3">blinkStatusValid</a>) {
<a name="l00390"></a>00390         <a class="code" href="main_8c.html#42a6b0f3c41a4e5e1722aca3c3a4b4b5" title="PRIVATE PROTOTYPES.">BlinkUSBStatus</a>();
<a name="l00391"></a>00391     }
<a name="l00392"></a>00392 
<a name="l00393"></a>00393     <span class="comment">// User Application USB tasks</span>
<a name="l00394"></a>00394     <span class="keywordflow">if</span>((<a class="code" href="usb__device_8h.html#c6e6520c8c73c4456ea7194acff5bb71" title="EXTERNS.">USBDeviceState</a> &lt; <a class="code" href="usb__device_8h.html#2aba92e0aaf8ccae5d19fa4de46d0c8f">CONFIGURED_STATE</a>)||(<a class="code" href="usb__hal__pic18_8h.html#692643ef2e9ce498623a4f83b60952ce">USBSuspendControl</a>==1)) <span class="keywordflow">return</span>;
<a name="l00395"></a>00395 
<a name="l00396"></a>00396         <span class="keywordflow">switch</span> (mode) {
<a name="l00397"></a>00397                 <span class="keywordflow">case</span> <a class="code" href="rangefinder_8h.html#d5357a5cc43a498c85b113357923f8aa">MODE_MEASURE</a>:
<a name="l00398"></a>00398                         <span class="keywordflow">if</span> (<a class="code" href="rangefinder_8c.html#7782486c96b2ff62dab69f99636a861e" title="Mesure une distance sur un télémètre.">measureDistance</a>(rangefinder)) {
<a name="l00399"></a>00399                                 <span class="keywordflow">if</span> (rangefinder &gt;= 7)
<a name="l00400"></a>00400                                         rangefinder = 0;
<a name="l00401"></a>00401                                 <span class="keywordflow">else</span>
<a name="l00402"></a>00402                                         rangefinder++;
<a name="l00403"></a>00403                         }
<a name="l00404"></a>00404                 <span class="keywordflow">break</span>;
<a name="l00405"></a>00405 
<a name="l00406"></a>00406                 <span class="keywordflow">case</span> <a class="code" href="rangefinder_8h.html#fe12ca5e671c24d97d5daa9f104b60fb">MODE_CALIBRATE</a>:
<a name="l00407"></a>00407                         <span class="keywordflow">if</span> (!<a class="code" href="usb__function__hid_8h.html#1e12a1ffede90ef301604c507344c427">HIDTxHandleBusy</a>(<a class="code" href="main_8c.html#92264d29f54b522e280bcad0d603e64a">USBInHandle</a>)) {
<a name="l00408"></a>00408                                 <span class="keywordflow">if</span> (status == <a class="code" href="_pc_interface_8h.html#30991f7f4aee5697ba90b2d170aab54f">CAL_START</a> || status == <a class="code" href="_pc_interface_8h.html#b3a6812f76031ffc540dce45f0cb296d">CAL_CONTINUE</a>) {
<a name="l00409"></a>00409                                         status = <a class="code" href="rangefinder_8c.html#6af556b86bdcad857be2fbe2599bcde4" title="Fonction de calibration semi-automatique d&amp;#39;un télémètre.">calibrate</a>(rangefinder, skipMeas);
<a name="l00410"></a>00410         
<a name="l00411"></a>00411                                         <span class="keywordflow">if</span> (status != <a class="code" href="_pc_interface_8h.html#b3a6812f76031ffc540dce45f0cb296d">CAL_CONTINUE</a>) {
<a name="l00412"></a>00412                                                 <a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[0] = <a class="code" href="_pc_interface_8h.html#9bf6cbf9e00dcc0a9927806a18024a48" title="Lance la calibration d&amp;#39;un télémètre [Carte capteurs].">CMD_CALIBRATE</a>;
<a name="l00413"></a>00413                                                 <a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[1] = status;
<a name="l00414"></a>00414                                                 <a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[2] = <a class="code" href="eeprom_8c.html#23c79775828a6c484c66ba66b42ca847" title="Lit dans l&amp;#39;EEPROM du PIC.">ReadEEPROM</a>(8*rangefinder + 1);
<a name="l00415"></a>00415                                                 <a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[3] = <a class="code" href="eeprom_8c.html#23c79775828a6c484c66ba66b42ca847" title="Lit dans l&amp;#39;EEPROM du PIC.">ReadEEPROM</a>(8*rangefinder + 2);
<a name="l00416"></a>00416                                                 <a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[4] = <a class="code" href="eeprom_8c.html#23c79775828a6c484c66ba66b42ca847" title="Lit dans l&amp;#39;EEPROM du PIC.">ReadEEPROM</a>(8*rangefinder + 3);
<a name="l00417"></a>00417                                                 <a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[5] = <a class="code" href="eeprom_8c.html#23c79775828a6c484c66ba66b42ca847" title="Lit dans l&amp;#39;EEPROM du PIC.">ReadEEPROM</a>(8*rangefinder + 4);
<a name="l00418"></a>00418                                                 <a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[6] = <a class="code" href="eeprom_8c.html#23c79775828a6c484c66ba66b42ca847" title="Lit dans l&amp;#39;EEPROM du PIC.">ReadEEPROM</a>(8*rangefinder + 5);
<a name="l00419"></a>00419                                                 <a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[7] = <a class="code" href="eeprom_8c.html#23c79775828a6c484c66ba66b42ca847" title="Lit dans l&amp;#39;EEPROM du PIC.">ReadEEPROM</a>(8*rangefinder + 6);
<a name="l00420"></a>00420                                                 <a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[8] = <a class="code" href="eeprom_8c.html#23c79775828a6c484c66ba66b42ca847" title="Lit dans l&amp;#39;EEPROM du PIC.">ReadEEPROM</a>(8*rangefinder + 7);
<a name="l00421"></a>00421                                                 <a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[9] = <a class="code" href="eeprom_8c.html#23c79775828a6c484c66ba66b42ca847" title="Lit dans l&amp;#39;EEPROM du PIC.">ReadEEPROM</a>(8*rangefinder + 8);
<a name="l00422"></a>00422                                                 <a class="code" href="main_8c.html#92264d29f54b522e280bcad0d603e64a">USBInHandle</a> = <a class="code" href="usb__function__hid_8h.html#83ec8b61af7d69c3e52fc9e92949764b">HIDTxPacket</a>(<a class="code" href="usb__config_8h.html#c4093f7479aadbd1a364d8caf7ac0fe7">HID_EP</a>, (<a class="code" href="_generic_type_defs_8h.html#4ae1dab0fb4b072a66584546209e7d58">BYTE</a>*) &amp;<a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>, 64);
<a name="l00423"></a>00423 
<a name="l00424"></a>00424                                                 <span class="keywordflow">if</span> (status == <a class="code" href="_pc_interface_8h.html#9b77ae51e68ff13de5c3187f9213de63">CAL_ERROR</a> || status == <a class="code" href="_pc_interface_8h.html#5b3e1e1135d0ee281abc8da6512aeb3f">CAL_DONE</a>)
<a name="l00425"></a>00425                                                         mode = <a class="code" href="rangefinder_8h.html#d5357a5cc43a498c85b113357923f8aa">MODE_MEASURE</a>;
<a name="l00426"></a>00426                                         }
<a name="l00427"></a>00427                                 }
<a name="l00428"></a>00428                         }
<a name="l00429"></a>00429                 <span class="keywordflow">break</span>;
<a name="l00430"></a>00430 
<a name="l00431"></a>00431                 <span class="keywordflow">default</span>:
<a name="l00432"></a>00432                         mode = <a class="code" href="rangefinder_8h.html#d5357a5cc43a498c85b113357923f8aa">MODE_MEASURE</a>;
<a name="l00433"></a>00433         }
<a name="l00434"></a>00434 
<a name="l00435"></a>00435     <span class="keywordflow">if</span>(!<a class="code" href="usb__function__hid_8h.html#21371467f39c3b935773bde1c81c768d">HIDRxHandleBusy</a>(<a class="code" href="main_8c.html#fdba80f833058ed3f3776089fe23821c">USBOutHandle</a>)) {
<a name="l00436"></a>00436         <span class="keywordflow">switch</span> (<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[0]) {
<a name="l00437"></a>00437                         <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#fe1dd8546b0a8cd30b19a0229205c8df" title="Reset du PIC.">CMD_RESET</a>:
<a name="l00438"></a>00438                                 <span class="comment">// Reset</span>
<a name="l00439"></a>00439                                 Reset();
<a name="l00440"></a>00440                         <span class="keywordflow">break</span>;
<a name="l00441"></a>00441 
<a name="l00442"></a>00442                         <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#d005dfb346cb7a56a2450a33f9cec621" title="Reset du PIC en mode bootloader.">CMD_BOOTLOADER</a>:
<a name="l00443"></a>00443                                 <span class="comment">// Reset sur le bootloader</span>
<a name="l00444"></a>00444                                 eeprom = <a class="code" href="eeprom_8c.html#23c79775828a6c484c66ba66b42ca847" title="Lit dans l&amp;#39;EEPROM du PIC.">ReadEEPROM</a>(0x00);
<a name="l00445"></a>00445                                 eeprom|= 0b1;
<a name="l00446"></a>00446                                 <a class="code" href="eeprom_8c.html#fd48dcf153304aa7a2726ca1b717ab14" title="Ecrit dans l&amp;#39;EEPROM du PIC.">WriteEEPROM</a>(0x00, eeprom);
<a name="l00447"></a>00447                                 Reset();
<a name="l00448"></a>00448                         <span class="keywordflow">break</span>;
<a name="l00449"></a>00449 
<a name="l00450"></a>00450                         <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#39f82f93564bba7925fd849ce7967a2b" title="Obtenir une information.">CMD_GET</a>:
<a name="l00451"></a>00451                                 <span class="keywordflow">if</span> (!<a class="code" href="usb__function__hid_8h.html#1e12a1ffede90ef301604c507344c427">HIDTxHandleBusy</a>(<a class="code" href="main_8c.html#92264d29f54b522e280bcad0d603e64a">USBInHandle</a>)) {
<a name="l00452"></a>00452                                         <a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[0] = <a class="code" href="_pc_interface_8h.html#46fec82bccecfa46f11015c448c79fe7" title="Réponse à une commande.">CMD_RESPOND</a>;
<a name="l00453"></a>00453         
<a name="l00454"></a>00454                                         <span class="keywordflow">switch</span> (<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[1]) {
<a name="l00455"></a>00455                                                 <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#1d93585646df2b625c747dce1d612831" title="Demande au PIC la source du Reset.">GET_RESET_SOURCE</a>:
<a name="l00456"></a>00456                                                         <a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[1] = <a class="code" href="main_8c.html#d1e58a5c30aa93b2b02ed582dc185fa5">resetSource</a>;
<a name="l00457"></a>00457                                                 <span class="keywordflow">break</span>;
<a name="l00458"></a>00458         
<a name="l00459"></a>00459                                                 <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#35512d717451a9b2fed3ee5a7ea996b3" title="Demande au PIC des infos sur le firmware.">GET_FIRMWARE_BUILD</a>:
<a name="l00460"></a>00460                                                         <a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[1] = <span class="charliteral">'\0'</span>;
<a name="l00461"></a>00461                                                         <a class="code" href="_compiler_8h.html#5e42f7bf7b2e4f4e8d9e79a02a3e0704">strcatpgm2ram</a>((<span class="keywordtype">char</span> *) &amp;<a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[0], (<span class="keyword">const</span> rom far <span class="keywordtype">char</span> *) <span class="stringliteral">"Carte capteurs 1.0\r\nOlivier BICHLER\r\n"</span>);
<a name="l00462"></a>00462                                                         <a class="code" href="_compiler_8h.html#5e42f7bf7b2e4f4e8d9e79a02a3e0704">strcatpgm2ram</a>((<span class="keywordtype">char</span> *) &amp;ToSendDataBuffer[0], (<span class="keyword">const</span> rom far <span class="keywordtype">char</span> *) __DATE__);
<a name="l00463"></a>00463                                                         <a class="code" href="_compiler_8h.html#5e42f7bf7b2e4f4e8d9e79a02a3e0704">strcatpgm2ram</a>((<span class="keywordtype">char</span> *) &amp;ToSendDataBuffer[0], (<span class="keyword">const</span> rom far <span class="keywordtype">char</span> *) <span class="stringliteral">" "</span>);
<a name="l00464"></a>00464                                                         <a class="code" href="_compiler_8h.html#5e42f7bf7b2e4f4e8d9e79a02a3e0704">strcatpgm2ram</a>((<span class="keywordtype">char</span> *) &amp;ToSendDataBuffer[0], (<span class="keyword">const</span> rom far <span class="keywordtype">char</span> *) __TIME__);
<a name="l00465"></a>00465                                                 <span class="keywordflow">break</span>;
<a name="l00466"></a>00466         
<a name="l00467"></a>00467                                                 <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#12e2decd6772ba16d9da85602bb09407" title="Demande la config TRIS des ports du PIC.">GET_PORTS_CONFIG</a>:
<a name="l00468"></a>00468                                                         ToSendDataBuffer[1] = TRISA;
<a name="l00469"></a>00469                                                         ToSendDataBuffer[2] = TRISB;
<a name="l00470"></a>00470                                                         ToSendDataBuffer[3] = TRISC;
<a name="l00471"></a>00471                                                         ToSendDataBuffer[4] = TRISD;
<a name="l00472"></a>00472                                                         ToSendDataBuffer[5] = TRISE;
<a name="l00473"></a>00473                                                 <span class="keywordflow">break</span>;
<a name="l00474"></a>00474         
<a name="l00475"></a>00475                                                 <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#ce80ddb6d57fbd68150570e3fbe9caac" title="Demande l&amp;#39;état des ports du PIC.">GET_PORTS_STATE</a>:
<a name="l00476"></a>00476                                                         ToSendDataBuffer[1] = PORTA;
<a name="l00477"></a>00477                                                         ToSendDataBuffer[2] = PORTB;
<a name="l00478"></a>00478                                                         ToSendDataBuffer[3] = PORTC;
<a name="l00479"></a>00479                                                         ToSendDataBuffer[4] = PORTD;
<a name="l00480"></a>00480                                                         ToSendDataBuffer[5] = PORTE;
<a name="l00481"></a>00481                                                 <span class="keywordflow">break</span>;
<a name="l00482"></a>00482 
<a name="l00483"></a>00483                                                 <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#b86bc6867060ef696ac4afd0272bc2ad" title="Demande au PIC les mesures des télémètres [Carte capteurs].">GET_RANGEFINDER_STATE</a>:
<a name="l00484"></a>00484                                                         <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++) {
<a name="l00485"></a>00485                                                                 dist = <a class="code" href="rangefinder_8c.html#905b1f6dd68931ac8abb5db4dac699bd" title="Donne la distance mesurée pour un télémètre.">getMeasuredDist</a>(i);
<a name="l00486"></a>00486                                                                 ToSendDataBuffer[1 + 4*i] = (dist &gt;&gt; 24) &amp; 0xFF;
<a name="l00487"></a>00487                                                                 ToSendDataBuffer[2 + 4*i] = (dist &gt;&gt; 16) &amp; 0xFF;
<a name="l00488"></a>00488                                                                 ToSendDataBuffer[3 + 4*i] = (dist &gt;&gt; 8) &amp; 0xFF;
<a name="l00489"></a>00489                                                                 ToSendDataBuffer[4 + 4*i] = dist &amp; 0xFF;
<a name="l00490"></a>00490                                                         }
<a name="l00491"></a>00491                                                 <span class="keywordflow">break</span>;
<a name="l00492"></a>00492 
<a name="l00493"></a>00493                                                 <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#dbbb127c4ba9a4f8adbbe4cd02fb72a5" title="Demande au PIC les valeurs de calibration des télémètres [Carte capteurs].">GET_RANGEFINDER_CALIBRATION</a>:
<a name="l00494"></a>00494                                                         ToSendDataBuffer[1] = <a class="code" href="eeprom_8c.html#23c79775828a6c484c66ba66b42ca847" title="Lit dans l&amp;#39;EEPROM du PIC.">ReadEEPROM</a>(8*<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[2] + 1);
<a name="l00495"></a>00495                                                         ToSendDataBuffer[2] = <a class="code" href="eeprom_8c.html#23c79775828a6c484c66ba66b42ca847" title="Lit dans l&amp;#39;EEPROM du PIC.">ReadEEPROM</a>(8*<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[2] + 2);
<a name="l00496"></a>00496                                                         ToSendDataBuffer[3] = <a class="code" href="eeprom_8c.html#23c79775828a6c484c66ba66b42ca847" title="Lit dans l&amp;#39;EEPROM du PIC.">ReadEEPROM</a>(8*<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[2] + 3);
<a name="l00497"></a>00497                                                         ToSendDataBuffer[4] = <a class="code" href="eeprom_8c.html#23c79775828a6c484c66ba66b42ca847" title="Lit dans l&amp;#39;EEPROM du PIC.">ReadEEPROM</a>(8*<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[2] + 4);
<a name="l00498"></a>00498                                                         ToSendDataBuffer[5] = <a class="code" href="eeprom_8c.html#23c79775828a6c484c66ba66b42ca847" title="Lit dans l&amp;#39;EEPROM du PIC.">ReadEEPROM</a>(8*<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[2] + 5);
<a name="l00499"></a>00499                                                         ToSendDataBuffer[6] = <a class="code" href="eeprom_8c.html#23c79775828a6c484c66ba66b42ca847" title="Lit dans l&amp;#39;EEPROM du PIC.">ReadEEPROM</a>(8*<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[2] + 6);
<a name="l00500"></a>00500                                                         ToSendDataBuffer[7] = <a class="code" href="eeprom_8c.html#23c79775828a6c484c66ba66b42ca847" title="Lit dans l&amp;#39;EEPROM du PIC.">ReadEEPROM</a>(8*<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[2] + 7);
<a name="l00501"></a>00501                                                         ToSendDataBuffer[8] = <a class="code" href="eeprom_8c.html#23c79775828a6c484c66ba66b42ca847" title="Lit dans l&amp;#39;EEPROM du PIC.">ReadEEPROM</a>(8*<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[2] + 8);
<a name="l00502"></a>00502                                                 <span class="keywordflow">break</span>;
<a name="l00503"></a>00503 
<a name="l00504"></a>00504                                                 <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#3c6b735f5e687c11085ca3f6a205994a" title="Demande au PIC l&amp;#39;état des capteurs de contact [Carte capteurs].">GET_TOR_STATE</a>:
<a name="l00505"></a>00505                                                         ToSendDataBuffer[1] = (<a class="code" href="tor_8h.html#66fbeb185230d0274b13ccf72cd19200" title="Capteur TOR N°8.">TOR8</a> &lt;&lt; 7) | (<a class="code" href="tor_8h.html#615acf2b6b28c28909d4fae7b56bb243" title="Capteur TOR N°7.">TOR7</a> &lt;&lt; 6) | (<a class="code" href="tor_8h.html#697dd3b9eb779116f52ae236509ead3e" title="Capteur TOR N°6.">TOR6</a> &lt;&lt; 5) | (<a class="code" href="tor_8h.html#482733c7fb92deb7114a94f0ba0843dd" title="Capteur TOR N°5.">TOR5</a> &lt;&lt; 4) | (<a class="code" href="tor_8h.html#5c7df4bbb2597eb3d6fcfb5dce2c8876" title="Capteur TOR N°4.">TOR4</a> &lt;&lt; 3) | (<a class="code" href="tor_8h.html#84f9b5b3a6b9933bf16d52ad20f2eb94" title="Capteur TOR N°3.">TOR3</a> &lt;&lt; 2) | (<a class="code" href="tor_8h.html#06420fd11a0dcfe3586a5d8658a52dd5" title="Capteur TOR N°2.">TOR2</a> &lt;&lt; 1) | <a class="code" href="tor_8h.html#5fa7ffe31d4462847086b6176fc3f57c" title="Capteur TOR N°1.">TOR1</a>;
<a name="l00506"></a>00506                                                         ToSendDataBuffer[2] = (<a class="code" href="tor_8h.html#5e1d0cc091ccfc8b2598762906b4a3d5" title="Capteur TOR N°16.">TOR16</a> &lt;&lt; 7) | (<a class="code" href="tor_8h.html#e5718a4d4b469aefe8a8dd085c1236b3" title="Capteur TOR N°15.">TOR15</a> &lt;&lt; 6) | (<a class="code" href="tor_8h.html#6030948e6d9a518483219e04152779fe" title="Capteur TOR N°14.">TOR14</a> &lt;&lt; 5) | (<a class="code" href="tor_8h.html#87f5b840d00ebb82f4fa7bc3eed9dae5" title="Capteur TOR N°13.">TOR13</a> &lt;&lt; 4) | (<a class="code" href="tor_8h.html#72021c8e3bf11ebedc069f2d4865dd3f" title="Capteur TOR N°12.">TOR12</a> &lt;&lt; 3) | (<a class="code" href="tor_8h.html#c6e367ee2bbf0345b32683c2a60d4594" title="Capteur TOR N°11.">TOR11</a> &lt;&lt; 2) | (<a class="code" href="tor_8h.html#94e2635046c87d72ad399f786b2e6d5d" title="Capteur TOR N°10.">TOR10</a> &lt;&lt; 1) | <a class="code" href="tor_8h.html#9fe40faad57360587065cdfa93eb6e48" title="Capteur TOR N°9.">TOR9</a>;
<a name="l00507"></a>00507                                                 <span class="keywordflow">break</span>;
<a name="l00508"></a>00508 
<a name="l00509"></a>00509                                                 <span class="keywordflow">default</span>:
<a name="l00510"></a>00510                                                         ToSendDataBuffer[1] = <a class="code" href="_pc_interface_8h.html#e950cf46a1155de5f6adfbdb614e0814" title="Demande inconnue.">ERR_UNKNOWN_GET</a>;
<a name="l00511"></a>00511                                         }
<a name="l00512"></a>00512 
<a name="l00513"></a>00513                                         <a class="code" href="main_8c.html#92264d29f54b522e280bcad0d603e64a">USBInHandle</a> = <a class="code" href="usb__function__hid_8h.html#83ec8b61af7d69c3e52fc9e92949764b">HIDTxPacket</a>(<a class="code" href="usb__config_8h.html#c4093f7479aadbd1a364d8caf7ac0fe7">HID_EP</a>, (<a class="code" href="_generic_type_defs_8h.html#4ae1dab0fb4b072a66584546209e7d58">BYTE</a>*) &amp;ToSendDataBuffer, 64);
<a name="l00514"></a>00514                                         <a class="code" href="main_8c.html#fdba80f833058ed3f3776089fe23821c">USBOutHandle</a> = <a class="code" href="usb__function__hid_8h.html#51903805a6cf95a33f689c5f95d9e915">HIDRxPacket</a>(<a class="code" href="usb__config_8h.html#c4093f7479aadbd1a364d8caf7ac0fe7">HID_EP</a>,(<a class="code" href="_generic_type_defs_8h.html#4ae1dab0fb4b072a66584546209e7d58">BYTE</a>*)&amp;<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>,64);               <span class="comment">// Re-arm the OUT endpoint for the next packet</span>
<a name="l00515"></a>00515                                 }
<a name="l00516"></a>00516                         <span class="keywordflow">break</span>;
<a name="l00517"></a>00517 
<a name="l00518"></a>00518                         <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#bb268d264836b9443ef23350814c0f68" title="Définir l&amp;#39;état d&amp;#39;un paramètre.">CMD_SET</a>:
<a name="l00519"></a>00519                                 <span class="keywordflow">switch</span> (<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[1]) {
<a name="l00520"></a>00520                                         <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#9671e443af58a672c1cac982aab3c217" title="Définir les entrées du PIC.">SET_PORTS_CONFIG_INPUTS</a>:
<a name="l00521"></a>00521                                                 TRISA|= <a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[2];
<a name="l00522"></a>00522                                                 TRISB|= <a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[3];
<a name="l00523"></a>00523                                                 TRISC|= <a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[4];
<a name="l00524"></a>00524                                                 TRISD|= <a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[5];
<a name="l00525"></a>00525                                                 TRISE|= <a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[6];
<a name="l00526"></a>00526                                         <span class="keywordflow">break</span>;
<a name="l00527"></a>00527 
<a name="l00528"></a>00528                                         <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#dc99d65115f431a881dd153a540ff00a" title="Définir les sorties du PIC.">SET_PORTS_CONFIG_OUTPUTS</a>:
<a name="l00529"></a>00529                                                 TRISA&amp;= ~<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[2];
<a name="l00530"></a>00530                                                 TRISB&amp;= ~<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[3];
<a name="l00531"></a>00531                                                 TRISC&amp;= ~<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[4];
<a name="l00532"></a>00532                                                 TRISD&amp;= ~<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[5];
<a name="l00533"></a>00533                                                 TRISE&amp;= ~<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[6];
<a name="l00534"></a>00534                                         <span class="keywordflow">break</span>;
<a name="l00535"></a>00535 
<a name="l00536"></a>00536                                         <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#4337af1b4705171921d322adc502d4db" title="Définir les sorties à l&amp;#39;état bas du PIC.">SET_PORTS_STATE_LOW</a>:
<a name="l00537"></a>00537                                                 LATA&amp;= ~<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[2];
<a name="l00538"></a>00538                                                 LATB&amp;= ~<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[3];
<a name="l00539"></a>00539                                                 LATC&amp;= ~<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[4];
<a name="l00540"></a>00540                                                 LATD&amp;= ~<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[5];
<a name="l00541"></a>00541                                                 LATE&amp;= ~<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[6];
<a name="l00542"></a>00542                                         <span class="keywordflow">break</span>;
<a name="l00543"></a>00543 
<a name="l00544"></a>00544                                         <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#802886de95962fcc1e851e2a8963dd7a" title="Définir les sorties à l&amp;#39;état haut du PIC.">SET_PORTS_STATE_HIGH</a>:
<a name="l00545"></a>00545                                                 LATA|= <a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[2];
<a name="l00546"></a>00546                                                 LATB|= <a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[3];
<a name="l00547"></a>00547                                                 LATC|= <a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[4];
<a name="l00548"></a>00548                                                 LATD|= <a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[5];
<a name="l00549"></a>00549                                                 LATE|= <a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[6];
<a name="l00550"></a>00550                                         <span class="keywordflow">break</span>;
<a name="l00551"></a>00551 
<a name="l00552"></a>00552                                         <span class="keywordflow">default</span>:
<a name="l00553"></a>00553                                         <span class="keywordflow">break</span>;
<a name="l00554"></a>00554                                 }
<a name="l00555"></a>00555 
<a name="l00556"></a>00556                                 <a class="code" href="main_8c.html#fdba80f833058ed3f3776089fe23821c">USBOutHandle</a> = <a class="code" href="usb__function__hid_8h.html#51903805a6cf95a33f689c5f95d9e915">HIDRxPacket</a>(<a class="code" href="usb__config_8h.html#c4093f7479aadbd1a364d8caf7ac0fe7">HID_EP</a>,(<a class="code" href="_generic_type_defs_8h.html#4ae1dab0fb4b072a66584546209e7d58">BYTE</a>*)&amp;<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>,64);               <span class="comment">// Re-arm the OUT endpoint for the next packet</span>
<a name="l00557"></a>00557                         <span class="keywordflow">break</span>;
<a name="l00558"></a>00558 
<a name="l00559"></a>00559                         <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#9bf6cbf9e00dcc0a9927806a18024a48" title="Lance la calibration d&amp;#39;un télémètre [Carte capteurs].">CMD_CALIBRATE</a>:
<a name="l00560"></a>00560                                 <span class="keywordflow">switch</span> (<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[1]) {
<a name="l00561"></a>00561                                         <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#30991f7f4aee5697ba90b2d170aab54f">CAL_START</a>:
<a name="l00562"></a>00562                                                 <span class="comment">// Démarre une calibration</span>
<a name="l00563"></a>00563                                                 mode = <a class="code" href="rangefinder_8h.html#fe12ca5e671c24d97d5daa9f104b60fb">MODE_CALIBRATE</a>;
<a name="l00564"></a>00564                                                 rangefinder = <a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[2];
<a name="l00565"></a>00565                                                 skipMeas = (<a class="code" href="_generic_type_defs_8h.html#54d65c7fa62e62c9754371e42f5111b9">BOOL</a>) <a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>[3];
<a name="l00566"></a>00566                                                 status = <a class="code" href="_pc_interface_8h.html#30991f7f4aee5697ba90b2d170aab54f">CAL_START</a>;
<a name="l00567"></a>00567                                         <span class="keywordflow">break</span>;
<a name="l00568"></a>00568 
<a name="l00569"></a>00569                                         <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#b3a6812f76031ffc540dce45f0cb296d">CAL_CONTINUE</a>:
<a name="l00570"></a>00570                                                 <span class="comment">// Continue la calibration après une demande d'action de l'utilisateur</span>
<a name="l00571"></a>00571                                                 status = <a class="code" href="_pc_interface_8h.html#b3a6812f76031ffc540dce45f0cb296d">CAL_CONTINUE</a>;
<a name="l00572"></a>00572                                         <span class="keywordflow">break</span>;
<a name="l00573"></a>00573 
<a name="l00574"></a>00574                                         <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#5c5f9642bc95f721df64c9fe1eac6f35">CAL_STOP</a>:
<a name="l00575"></a>00575                                                 <span class="comment">// Arrête la calibration</span>
<a name="l00576"></a>00576                                                 mode = <a class="code" href="rangefinder_8h.html#d5357a5cc43a498c85b113357923f8aa">MODE_MEASURE</a>;
<a name="l00577"></a>00577                                                 rangefinder = 0;
<a name="l00578"></a>00578                                         <span class="keywordflow">break</span>;
<a name="l00579"></a>00579 
<a name="l00580"></a>00580                                         <span class="keywordflow">default</span>:
<a name="l00581"></a>00581                                         <span class="keywordflow">break</span>;
<a name="l00582"></a>00582                                 }
<a name="l00583"></a>00583 
<a name="l00584"></a>00584                                 <a class="code" href="main_8c.html#fdba80f833058ed3f3776089fe23821c">USBOutHandle</a> = <a class="code" href="usb__function__hid_8h.html#51903805a6cf95a33f689c5f95d9e915">HIDRxPacket</a>(<a class="code" href="usb__config_8h.html#c4093f7479aadbd1a364d8caf7ac0fe7">HID_EP</a>,(<a class="code" href="_generic_type_defs_8h.html#4ae1dab0fb4b072a66584546209e7d58">BYTE</a>*)&amp;<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>,64);               <span class="comment">// Re-arm the OUT endpoint for the next packet</span>
<a name="l00585"></a>00585                         <span class="keywordflow">break</span>;
<a name="l00586"></a>00586 
<a name="l00587"></a>00587                         <span class="keywordflow">default</span>:
<a name="l00588"></a>00588                                 <span class="comment">// Commande non reconnue</span>
<a name="l00589"></a>00589                                 <span class="keywordflow">if</span> (!<a class="code" href="usb__function__hid_8h.html#1e12a1ffede90ef301604c507344c427">HIDTxHandleBusy</a>(<a class="code" href="main_8c.html#92264d29f54b522e280bcad0d603e64a">USBInHandle</a>)) {
<a name="l00590"></a>00590                                         ToSendDataBuffer[0] = <a class="code" href="_pc_interface_8h.html#46fec82bccecfa46f11015c448c79fe7" title="Réponse à une commande.">CMD_RESPOND</a>;
<a name="l00591"></a>00591                                         ToSendDataBuffer[1] = <a class="code" href="_pc_interface_8h.html#ddfc7b504ad733cd1f4458751222e4a3" title="Commande inconnue.">ERR_UNKNOWN_CMD</a>;
<a name="l00592"></a>00592 
<a name="l00593"></a>00593                                         <a class="code" href="main_8c.html#92264d29f54b522e280bcad0d603e64a">USBInHandle</a> = <a class="code" href="usb__function__hid_8h.html#83ec8b61af7d69c3e52fc9e92949764b">HIDTxPacket</a>(<a class="code" href="usb__config_8h.html#c4093f7479aadbd1a364d8caf7ac0fe7">HID_EP</a>, (<a class="code" href="_generic_type_defs_8h.html#4ae1dab0fb4b072a66584546209e7d58">BYTE</a>*) &amp;ToSendDataBuffer, 64);
<a name="l00594"></a>00594                                         <a class="code" href="main_8c.html#fdba80f833058ed3f3776089fe23821c">USBOutHandle</a> = <a class="code" href="usb__function__hid_8h.html#51903805a6cf95a33f689c5f95d9e915">HIDRxPacket</a>(<a class="code" href="usb__config_8h.html#c4093f7479aadbd1a364d8caf7ac0fe7">HID_EP</a>,(<a class="code" href="_generic_type_defs_8h.html#4ae1dab0fb4b072a66584546209e7d58">BYTE</a>*)&amp;<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>,64);               <span class="comment">// Re-arm the OUT endpoint for the next packet</span>
<a name="l00595"></a>00595                                 }
<a name="l00596"></a>00596                 }
<a name="l00597"></a>00597     }
<a name="l00598"></a>00598 }<span class="comment">//end ProcessIO</span>
</pre></div>
<p>

<p>
<div class="dynheader">
Voici le graphe d'appel pour cette fonction :</div>
<div class="dynsection">
<p><center><img src="main_8c_ace5bc936ba3a482762863d6da13c941_cgraph.png" border="0" usemap="#main_8c_ace5bc936ba3a482762863d6da13c941_cgraph_map" alt=""></center>
<map name="main_8c_ace5bc936ba3a482762863d6da13c941_cgraph_map">
<area shape="rect" href="main_8c.html#42a6b0f3c41a4e5e1722aca3c3a4b4b5" title="PRIVATE PROTOTYPES." alt="" coords="153,5,287,35"><area shape="rect" href="rangefinder_8c.html#6af556b86bdcad857be2fbe2599bcde4" title="Fonction de calibration semi&#45;automatique d&#39;un télémètre." alt="" coords="179,160,261,189"><area shape="rect" href="rangefinder_8c.html#905b1f6dd68931ac8abb5db4dac699bd" title="Donne la distance mesurée pour un télémètre." alt="" coords="339,61,483,91"><area shape="rect" href="rangefinder_8c.html#7782486c96b2ff62dab69f99636a861e" title="Mesure une distance sur un télémètre." alt="" coords="337,117,484,147"><area shape="rect" href="eeprom_8c.html#23c79775828a6c484c66ba66b42ca847" title="Lit dans l&#39;EEPROM du PIC." alt="" coords="347,176,475,205"><area shape="rect" href="eeprom_8c.html#fd48dcf153304aa7a2726ca1b717ab14" title="Ecrit dans l&#39;EEPROM du PIC." alt="" coords="345,240,476,269"><area shape="rect" href="rangefinder_8c.html#438675a7ef66fd328e56e27a7bff362f" title="Sélection d&#39;un télémètre." alt="" coords="533,91,685,120"><area shape="rect" href="rangefinder_8c.html#6d00149bf7ccb02aed245c211ce25826" title="Envoie une impulsion ultrason." alt="" coords="561,144,657,173"></map>
</div>

</div>
</div><p>
<a class="anchor" name="d3060f9b061e802bba79e880c4484505"></a><!-- doxytag: member="main.c::ResetSource" ref="d3060f9b061e802bba79e880c4484505" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ResetSource           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="main_8c.html#d3060f9b061e802bba79e880c4484505" title="ResetSource() permet de connaitre l&#39;origine du dernier reset tout en réinitialisant...">ResetSource()</a> permet de connaitre l'origine du dernier reset tout en réinitialisant correctement les registres pour le prochain reset. 
<p>
Si elle n'est pas appelée à chaque démarrage du PIC, les registres ne seront pas correctement réinitialisées et l'origine du reset renvoyée par cette fonction pourra être erronée.<p>
<dl class="return" compact><dt><b>Renvoie:</b></dt><dd>source source du dernier RESET, peut valoir une des constantes RESET_*. </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00960"></a>00960                        {
<a name="l00961"></a>00961         <span class="keywordtype">char</span> src;
<a name="l00962"></a>00962 
<a name="l00963"></a>00963         <span class="keywordflow">if</span> (!RCONbits.POR)
<a name="l00964"></a>00964                 <span class="comment">// Power-on Reset</span>
<a name="l00965"></a>00965                 src = <a class="code" href="_pc_interface_8h.html#524422e4fc9d394e0fd93b7c237f7a0d" title="Power-on Reset.">RESET_SOURCE_POR</a>;
<a name="l00966"></a>00966         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!RCONbits.RI)
<a name="l00967"></a>00967                 <span class="comment">// RESET Instruction</span>
<a name="l00968"></a>00968                 src = <a class="code" href="_pc_interface_8h.html#245ebb4ee7f1ea33154309bd1ed81f38" title="RESET Instruction.">RESET_SOURCE_RI</a>;
<a name="l00969"></a>00969         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!RCONbits.BOR) <span class="comment">// &amp;&amp; RCONbits.POR</span>
<a name="l00970"></a>00970                 <span class="comment">// Brown-out Reset</span>
<a name="l00971"></a>00971                 src = <a class="code" href="_pc_interface_8h.html#03a64d894da05e34b82b30d9ce329214" title="Brown-out Reset.">RESET_SOURCE_BOR</a>;
<a name="l00972"></a>00972         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!RCONbits.TO)
<a name="l00973"></a>00973                 <span class="comment">// Watchdog Time-out Reset</span>
<a name="l00974"></a>00974                 src = <a class="code" href="_pc_interface_8h.html#f12060aee7309d1d1c1ced73ee42bfdf" title="Watchdog Time-out Reset.">RESET_SOURCE_WDT</a>;
<a name="l00975"></a>00975         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (STKPTRbits.STKFUL)
<a name="l00976"></a>00976                 <span class="comment">// Stack Full Reset (STVREN = 1)</span>
<a name="l00977"></a>00977                 src = <a class="code" href="_pc_interface_8h.html#94baa8b4f808e0f4c6ca558f1e107e25" title="Stack Full Reset.">RESET_SOURCE_STKFUL</a>;
<a name="l00978"></a>00978         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (STKPTRbits.STKUNF)
<a name="l00979"></a>00979                 <span class="comment">// Stack Underflow Reset (STVREN = 1)</span>
<a name="l00980"></a>00980                 src = <a class="code" href="_pc_interface_8h.html#aed300e8316412f12e8f29cf667a391d" title="Stack Underflow Reset.">RESET_SOURCE_STKUNF</a>;
<a name="l00981"></a>00981         <span class="keywordflow">else</span>
<a name="l00982"></a>00982                 <span class="comment">// Master Clear Reset</span>
<a name="l00983"></a>00983                 src = <a class="code" href="_pc_interface_8h.html#39d66f0028a870a4ca903fdb417464f2" title="Master Clear Reset.">RESET_SOURCE_MCLR</a>;
<a name="l00984"></a>00984 
<a name="l00985"></a>00985         <span class="comment">// Réinitialisation de tous les bits de status</span>
<a name="l00986"></a>00986         RCONbits.RI = 1;
<a name="l00987"></a>00987         RCONbits.TO = 1;
<a name="l00988"></a>00988         RCONbits.PD = 1;
<a name="l00989"></a>00989         RCONbits.POR = 1;
<a name="l00990"></a>00990         RCONbits.BOR = 1;
<a name="l00991"></a>00991         STKPTRbits.STKFUL = 0;
<a name="l00992"></a>00992         STKPTRbits.STKUNF = 0;
<a name="l00993"></a>00993 
<a name="l00994"></a>00994         <span class="keywordflow">return</span> src;
<a name="l00995"></a>00995 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d39fa1008b49fb91555086e40710d573"></a><!-- doxytag: member="main.c::USBCB_SOF_Handler" ref="d39fa1008b49fb91555086e40710d573" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBCB_SOF_Handler           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The USB host sends out a SOF packet to full-speed devices every 1 ms. 
<p>
This interrupt may be useful for isochronous pipes. End designers should implement callback routine as necessary. <div class="fragment"><pre class="fragment"><a name="l00788"></a>00788 {
<a name="l00789"></a>00789     <span class="comment">// No need to clear UIRbits.SOFIF to 0 here.</span>
<a name="l00790"></a>00790     <span class="comment">// Callback caller is already doing that.</span>
<a name="l00791"></a>00791 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a1730f3cc119bd8eb04d9b55ebed56e6"></a><!-- doxytag: member="main.c::USBCBCheckOtherReq" ref="a1730f3cc119bd8eb04d9b55ebed56e6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBCBCheckOtherReq           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When SETUP packets arrive from the host, some firmware must process the request and respond appropriately to fulfill the request. 
<p>
Some of the SETUP packets will be for standard USB "chapter 9" (as in, fulfilling chapter 9 of the official USB specifications) requests, while others may be specific to the USB device class that is being implemented. For example, a HID class device needs to be able to respond to "GET REPORT" type of requests. This is not a standard USB chapter 9 request, and therefore not handled by <a class="el" href="usb__device_8c.html">usb_device.c</a>. Instead this request should be handled by class specific firmware, such as that contained in <a class="el" href="usb__function__hid_8c.html">usb_function_hid.c</a>. <div class="fragment"><pre class="fragment"><a name="l00838"></a>00838 {
<a name="l00839"></a>00839     <a class="code" href="usb__function__hid_8h.html#5e0b02add954ecf19bcdef679a58988b" title="Section: PUBLIC PROTOTYPES.">USBCheckHIDRequest</a>();
<a name="l00840"></a>00840 }<span class="comment">//end</span>
</pre></div>
<p>

<p>
<div class="dynheader">
Voici le graphe d'appel pour cette fonction :</div>
<div class="dynsection">
<p><center><img src="main_8c_a1730f3cc119bd8eb04d9b55ebed56e6_cgraph.png" border="0" usemap="#main_8c_a1730f3cc119bd8eb04d9b55ebed56e6_cgraph_map" alt=""></center>
<map name="main_8c_a1730f3cc119bd8eb04d9b55ebed56e6_cgraph_map">
<area shape="rect" href="usb__function__hid_8h.html#5e0b02add954ecf19bcdef679a58988b" title="Section: PUBLIC PROTOTYPES." alt="" coords="249,32,436,61"><area shape="rect" href="usb__function__hid_8c.html#fb60fd12cb265cc70fd3b2d11802cd09" title="PRIVATE PROTOTYPES." alt="" coords="485,5,664,35"><area shape="rect" href="usb__function__hid_8c.html#6d8be1c6f7f1a3ffb6c3b56ae1f067a6" title="HIDSetReportHandler" alt="" coords="487,59,663,88"></map>
</div>

</div>
</div><p>
<a class="anchor" name="e6717d77804b36ca26a975fd0bee6f01"></a><!-- doxytag: member="main.c::USBCBErrorHandler" ref="e6717d77804b36ca26a975fd0bee6f01" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBCBErrorHandler           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The purpose of this callback is mainly for debugging during development. 
<p>
Check UEIR to see which error causes the interrupt. <div class="fragment"><pre class="fragment"><a name="l00799"></a>00799 {
<a name="l00800"></a>00800     <span class="comment">// No need to clear UEIR to 0 here.</span>
<a name="l00801"></a>00801     <span class="comment">// Callback caller is already doing that.</span>
<a name="l00802"></a>00802 
<a name="l00803"></a>00803         <span class="comment">// Typically, user firmware does not need to do anything special</span>
<a name="l00804"></a>00804         <span class="comment">// if a USB error occurs.  For example, if the host sends an OUT</span>
<a name="l00805"></a>00805         <span class="comment">// packet to your device, but the packet gets corrupted (ex:</span>
<a name="l00806"></a>00806         <span class="comment">// because of a bad connection, or the user unplugs the</span>
<a name="l00807"></a>00807         <span class="comment">// USB cable during the transmission) this will typically set</span>
<a name="l00808"></a>00808         <span class="comment">// one or more USB error interrupt flags.  Nothing specific</span>
<a name="l00809"></a>00809         <span class="comment">// needs to be done however, since the SIE will automatically</span>
<a name="l00810"></a>00810         <span class="comment">// send a "NAK" packet to the host.  In response to this, the</span>
<a name="l00811"></a>00811         <span class="comment">// host will normally retry to send the packet again, and no</span>
<a name="l00812"></a>00812         <span class="comment">// data loss occurs.  The system will typically recover</span>
<a name="l00813"></a>00813         <span class="comment">// automatically, without the need for application firmware</span>
<a name="l00814"></a>00814         <span class="comment">// intervention.</span>
<a name="l00815"></a>00815         
<a name="l00816"></a>00816         <span class="comment">// Nevertheless, this callback function is provided, such as</span>
<a name="l00817"></a>00817         <span class="comment">// for debugging purposes.</span>
<a name="l00818"></a>00818 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e69da16b1f966a62cdd1831df5561cbf"></a><!-- doxytag: member="main.c::USBCBInitEP" ref="e69da16b1f966a62cdd1831df5561cbf" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBCBInitEP           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is called when the device becomes initialized, which occurs after the host sends a SET_CONFIGURATION (wValue not = 0) request. 
<p>
This callback function should initialize the endpoints for the device's usage according to the current configuration. <div class="fragment"><pre class="fragment"><a name="l00865"></a>00865 {
<a name="l00866"></a>00866     <span class="comment">//enable the HID endpoint</span>
<a name="l00867"></a>00867     <a class="code" href="usb__device_8h.html#25c6b82e249f563f00732a7e242c4267">USBEnableEndpoint</a>(<a class="code" href="usb__config_8h.html#c4093f7479aadbd1a364d8caf7ac0fe7">HID_EP</a>,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
<a name="l00868"></a>00868     <span class="comment">//Re-arm the OUT endpoint for the next packet</span>
<a name="l00869"></a>00869     <a class="code" href="main_8c.html#fdba80f833058ed3f3776089fe23821c">USBOutHandle</a> = <a class="code" href="usb__function__hid_8h.html#51903805a6cf95a33f689c5f95d9e915">HIDRxPacket</a>(<a class="code" href="usb__config_8h.html#c4093f7479aadbd1a364d8caf7ac0fe7">HID_EP</a>,(<a class="code" href="_generic_type_defs_8h.html#4ae1dab0fb4b072a66584546209e7d58">BYTE</a>*)&amp;<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0" title="INCLUDES.">ReceivedDataBuffer</a>,64);
<a name="l00870"></a>00870 }
</pre></div>
<p>

<p>
<div class="dynheader">
Voici le graphe d'appel pour cette fonction :</div>
<div class="dynsection">
<p><center><img src="main_8c_e69da16b1f966a62cdd1831df5561cbf_cgraph.png" border="0" usemap="#main_8c_e69da16b1f966a62cdd1831df5561cbf_cgraph_map" alt=""></center>
<map name="main_8c_e69da16b1f966a62cdd1831df5561cbf_cgraph_map">
<area shape="rect" href="usb__device_8h.html#25c6b82e249f563f00732a7e242c4267" title="USBEnableEndpoint" alt="" coords="176,5,344,35"><area shape="rect" href="usb__device_8h.html#1901fa27385226b6cdad1f5b091e5374" title="USBConfigureEndpoint" alt="" coords="393,5,583,35"></map>
</div>

</div>
</div><p>
<a class="anchor" name="0349054fd83e147e1a88e375748e8caf"></a><!-- doxytag: member="main.c::USBCBSendResume" ref="0349054fd83e147e1a88e375748e8caf" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBCBSendResume           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b></b></dt><dd>The USB specifications allow some types of USB peripheral devices to wake up a host PC (such as if it is in a low power suspend to RAM state). This can be a very useful feature in some USB applications, such as an Infrared remote control receiver. If a user presses the "power" button on a remote control, it is nice that the IR receiver can detect this signalling, and then send a USB "command" to the PC to wake up.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The <a class="el" href="usb__device_8h.html#0349054fd83e147e1a88e375748e8caf">USBCBSendResume()</a> "callback" function is used to send this special USB signalling which wakes up the PC. This function may be called by application firmware to wake up the PC. This function should only be called when:</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>1. The USB driver used on the host PC supports the remote wakeup capability. <br>
 2. The USB configuration descriptor indicates the device is remote wakeup capable in the bmAttributes field. <br>
 3. The USB host PC is currently sleeping, and has previously sent your device a SET FEATURE setup packet which "armed" the remote wakeup capability.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>This callback should send a RESUME signal that has the period of 1-15ms.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Interrupt vs. Polling <br>
 -Primary clock <br>
 -Secondary clock ***** MAKE NOTES ABOUT THIS ******* <br>
 &gt; Can switch to primary first by calling <a class="el" href="usb__device_8h.html#cb07fd7b59801b89093d5f5a375a1bb1" title="This function is called when the USB interrupt bit is set In this example the interrupt...">USBCBWakeFromSuspend()</a></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The modifiable section in this routine should be changed to meet the application needs. Current implementation temporary blocks other functions from executing for a period of 1-13 ms depending on the core frequency.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>According to USB 2.0 specification section 7.1.7.7, "The remote wakeup device must hold the resume signaling for at lest 1 ms but for no more than 15 ms." <br>
 The idea here is to use a delay counter loop, using a common value that would work over a wide range of core frequencies. <br>
 That value selected is 1800. See table below: <br>
 ========================================================== <br>
 Core Freq(MHz) MIP RESUME Signal Period (ms) <br>
 ========================================================== <br>
 48 12 1.05 <br>
 4 1 12.6 <br>
 ========================================================== <br>
 * These timing could be incorrect when using code optimization or extended instruction mode, or when having other interrupts enabled. Make sure to verify using the MPLAB SIM's Stopwatch and verify the actual signal on an oscilloscope. </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00938"></a>00938 {
<a name="l00939"></a>00939     <span class="keyword">static</span> <a class="code" href="_generic_type_defs_8h.html#2b0e863dadf920709ec53d9088ee7c91">WORD</a> delay_count;
<a name="l00940"></a>00940     
<a name="l00941"></a>00941     <a class="code" href="usb__hal__pic18_8h.html#2cbdeb8a88e95229eeb28b19a5e76a3b">USBResumeControl</a> = 1;                <span class="comment">// Start RESUME signaling</span>
<a name="l00942"></a>00942     
<a name="l00943"></a>00943     delay_count = 1800U;                <span class="comment">// Set RESUME line for 1-13 ms</span>
<a name="l00944"></a>00944     <span class="keywordflow">do</span>
<a name="l00945"></a>00945     {
<a name="l00946"></a>00946         delay_count--;
<a name="l00947"></a>00947     }<span class="keywordflow">while</span>(delay_count);
<a name="l00948"></a>00948     <a class="code" href="usb__hal__pic18_8h.html#2cbdeb8a88e95229eeb28b19a5e76a3b">USBResumeControl</a> = 0;
<a name="l00949"></a>00949 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="85c176c4ca674eb30b43b414f6a66260"></a><!-- doxytag: member="main.c::USBCBStdSetDscHandler" ref="85c176c4ca674eb30b43b414f6a66260" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBCBStdSetDscHandler           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <a class="el" href="usb__device_8h.html#85c176c4ca674eb30b43b414f6a66260" title="The USBCBStdSetDscHandler() callback function is called when a SETUP, bRequest: SET_DESCRIPTOR...">USBCBStdSetDscHandler()</a> callback function is called when a SETUP, bRequest: SET_DESCRIPTOR request arrives. 
<p>
Typically SET_DESCRIPTOR requests are not used in most applications, and it is optional to support this type of request. <div class="fragment"><pre class="fragment"><a name="l00851"></a>00851 {
<a name="l00852"></a>00852     <span class="comment">// Must claim session ownership if supporting this request</span>
<a name="l00853"></a>00853 }<span class="comment">//end</span>
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="24bc7f902cfd3ef505708c71099ca32a"></a><!-- doxytag: member="main.c::USBCBSuspend" ref="24bc7f902cfd3ef505708c71099ca32a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBCBSuspend           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call back that is invoked when a USB suspend is detected. 
<p>
Section: CALLBACKS. <div class="fragment"><pre class="fragment"><a name="l00702"></a>00702 {
<a name="l00703"></a>00703         <span class="comment">//Example power saving code.  Insert appropriate code here for the desired</span>
<a name="l00704"></a>00704         <span class="comment">//application behavior.  If the microcontroller will be put to sleep, a</span>
<a name="l00705"></a>00705         <span class="comment">//process similar to that shown below may be used:</span>
<a name="l00706"></a>00706         
<a name="l00707"></a>00707         <span class="comment">//ConfigureIOPinsForLowPower();</span>
<a name="l00708"></a>00708         <span class="comment">//SaveStateOfAllInterruptEnableBits();</span>
<a name="l00709"></a>00709         <span class="comment">//DisableAllInterruptEnableBits();</span>
<a name="l00710"></a>00710         <span class="comment">//EnableOnlyTheInterruptsWhichWillBeUsedToWakeTheMicro();       //should enable at least USBActivityIF as a wake source</span>
<a name="l00711"></a>00711         <span class="comment">//Sleep();</span>
<a name="l00712"></a>00712         <span class="comment">//RestoreStateOfAllPreviouslySavedInterruptEnableBits();        //Preferrably, this should be done in the USBCBWakeFromSuspend() function instead.</span>
<a name="l00713"></a>00713         <span class="comment">//RestoreIOPinsToNormal();                                                                      //Preferrably, this should be done in the USBCBWakeFromSuspend() function instead.</span>
<a name="l00714"></a>00714 
<a name="l00715"></a>00715         <span class="comment">//IMPORTANT NOTE: Do not clear the USBActivityIF (ACTVIF) bit here.  This bit is </span>
<a name="l00716"></a>00716         <span class="comment">//cleared inside the usb_device.c file.  Clearing USBActivityIF here will cause </span>
<a name="l00717"></a>00717         <span class="comment">//things to not work as intended.       </span>
<a name="l00718"></a>00718 
<a name="l00719"></a>00719 <span class="preprocessor">    #if defined(__C30__)</span>
<a name="l00720"></a>00720 <span class="preprocessor"></span><span class="preprocessor">    #if 0</span>
<a name="l00721"></a>00721 <span class="preprocessor"></span>        <a class="code" href="usb__hal__pic18_8h.html#ba77d553dab6b24f442c2415b48d93e7">U1EIR</a> = 0xFFFF;
<a name="l00722"></a>00722         <a class="code" href="usb__hal__pic18_8h.html#dcc39d6045679c6ea0af970ae03e3b32">U1IR</a> = 0xFFFF;
<a name="l00723"></a>00723         U1OTGIR = 0xFFFF;
<a name="l00724"></a>00724         IFS5bits.USB1IF = 0;
<a name="l00725"></a>00725         IEC5bits.USB1IE = 1;
<a name="l00726"></a>00726         U1OTGIEbits.ACTVIE = 1;
<a name="l00727"></a>00727         U1OTGIRbits.ACTVIF = 1;
<a name="l00728"></a>00728         TRISA &amp;= 0xFF3F;
<a name="l00729"></a>00729         LATAbits.LATA6 = 1;
<a name="l00730"></a>00730         Sleep();
<a name="l00731"></a>00731         LATAbits.LATA6 = 0;
<a name="l00732"></a>00732 <span class="preprocessor">    #endif</span>
<a name="l00733"></a>00733 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00734"></a>00734 <span class="preprocessor"></span>}
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="cb07fd7b59801b89093d5f5a375a1bb1"></a><!-- doxytag: member="main.c::USBCBWakeFromSuspend" ref="cb07fd7b59801b89093d5f5a375a1bb1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBCBWakeFromSuspend           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is called when the USB interrupt bit is set In this example the interrupt is only used when the device goes to sleep when it receives a USB suspend command. 
<p>
The host may put USB peripheral devices in low power suspend mode (by "sending" 3+ms of idle). Once in suspend mode, the host may wake the device back up by sending non- idle state signalling. <br>
 This call back is invoked when a wakeup from USB suspend is detected. <div class="fragment"><pre class="fragment"><a name="l00770"></a>00770 {
<a name="l00771"></a>00771         <span class="comment">// If clock switching or other power savings measures were taken when</span>
<a name="l00772"></a>00772         <span class="comment">// executing the USBCBSuspend() function, now would be a good time to</span>
<a name="l00773"></a>00773         <span class="comment">// switch back to normal full power run mode conditions.  The host allows</span>
<a name="l00774"></a>00774         <span class="comment">// a few milliseconds of wakeup time, after which the device must be </span>
<a name="l00775"></a>00775         <span class="comment">// fully back to normal, and capable of receiving and processing USB</span>
<a name="l00776"></a>00776         <span class="comment">// packets.  In order to do this, the USB module must receive proper</span>
<a name="l00777"></a>00777         <span class="comment">// clocking (IE: 48MHz clock must be available to SIE for full speed USB</span>
<a name="l00778"></a>00778         <span class="comment">// operation).</span>
<a name="l00779"></a>00779 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="655d748c28aad5b529f5826b50fe1251"></a><!-- doxytag: member="main.c::UserInit" ref="655d748c28aad5b529f5826b50fe1251" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UserInit           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Routine d'initialisation utilisateur. 
<p>
C'est dans cette fonction que sont centralisées toutes les initialisations du PIC, hormis pour l'USB. <dl class="see" compact><dt><b>Voir également:</b></dt><dd><a class="el" href="main_8c.html#4f80a71f6079faf7617114a373a05017" title="Centralise les routines d&#39;initialisation.">InitializeSystem()</a> </dd></dl>

<p>
Initialisation des composants externes <div class="fragment"><pre class="fragment"><a name="l00332"></a>00332 {
<a name="l00333"></a>00333         <span class="comment">// ResetSource() permet de connaitre l'origine du dernier reset tout en réinitialisant correctement</span>
<a name="l00334"></a>00334         <span class="comment">// les registres pour le prochain reset. Si elle n'est pas appelée à chaque démarrage du PIC, les</span>
<a name="l00335"></a>00335         <span class="comment">// registres ne seront pas correctement réinitialisées et l'origine du reset renvoyée par cette</span>
<a name="l00336"></a>00336         <span class="comment">// fonction pourra être erronée.</span>
<a name="l00337"></a>00337         <a class="code" href="main_8c.html#d1e58a5c30aa93b2b02ed582dc185fa5">resetSource</a> = <a class="code" href="main_8c.html#d3060f9b061e802bba79e880c4484505" title="ResetSource() permet de connaitre l&amp;#39;origine du dernier reset tout en réinitialisant...">ResetSource</a>();
<a name="l00338"></a>00338 
<a name="l00339"></a>00339         <span class="comment">// Configuration interruptions</span>
<a name="l00340"></a>00340         RCONbits.IPEN = 1;              <span class="comment">// Enable priority levels on interrupts</span>
<a name="l00341"></a>00341         INTCONbits.GIE = 1;             <span class="comment">// Enables all high priority interrupts</span>
<a name="l00342"></a>00342         INTCONbits.PEIE = 1;    <span class="comment">// Enables all low priority peripheral interrupts</span>
<a name="l00343"></a>00343 
<a name="l00344"></a>00344         <span class="comment">// Configuration de l'I2C</span>
<a name="l00345"></a>00345 <span class="comment">//      OpenI2C(MASTER, SLEW_OFF);</span>
<a name="l00346"></a>00346 
<a name="l00351"></a>00351     <span class="comment">//Initialize all of the LED pins</span>
<a name="l00352"></a>00352     <a class="code" href="_hardware_profile_8h.html#27e6bd4d852b6452a2aeadd96df5139e" title="LED.">mInitAllLEDs</a>();
<a name="l00353"></a>00353 
<a name="l00354"></a>00354     <span class="comment">//initialize the variable holding the handle for the last</span>
<a name="l00355"></a>00355     <span class="comment">// transmission</span>
<a name="l00356"></a>00356     <a class="code" href="main_8c.html#fdba80f833058ed3f3776089fe23821c">USBOutHandle</a> = 0;
<a name="l00357"></a>00357     <a class="code" href="main_8c.html#92264d29f54b522e280bcad0d603e64a">USBInHandle</a> = 0;
<a name="l00358"></a>00358 
<a name="l00359"></a>00359     <a class="code" href="main_8c.html#663117df30d6ab9eef2e1280f4956ec3">blinkStatusValid</a> = <a class="code" href="_generic_type_defs_8h.html#fbf708854fe02af8475a9ba02f3196cba82764c3079aea4e60c80e45befbb839">TRUE</a>;
<a name="l00360"></a>00360 
<a name="l00361"></a>00361         <span class="comment">// Télémétrie</span>
<a name="l00362"></a>00362         <a class="code" href="rangefinder_8h.html#b2ccc17e75486345af1d9d23a032a6e2" title="Initialise l&amp;#39;interface avec le système de télémétrie.">initRangefinder</a>();
<a name="l00363"></a>00363 
<a name="l00364"></a>00364         <span class="comment">// Configuration du timer1</span>
<a name="l00365"></a>00365         PIE1bits.TMR1IE = 1;    <span class="comment">// Autorise les interruption par dépassement du Timer (Timer overflow)</span>
<a name="l00366"></a>00366         OpenTimer1(TIMER_INT_ON         <span class="comment">// active le timer1</span>
<a name="l00367"></a>00367                  &amp; T1_16BIT_RW                  <span class="comment">// compte sur 16 bits</span>
<a name="l00368"></a>00368                  &amp; T1_SOURCE_INT                <span class="comment">// utilise l'horloge interne</span>
<a name="l00369"></a>00369                  &amp; T1_PS_1_1                    <span class="comment">// incrémente le compteur à chaque cycle (1:1)</span>
<a name="l00370"></a>00370                  &amp; T1_OSC1EN_OFF                <span class="comment">// pas d'oscillateur sur le timer1</span>
<a name="l00371"></a>00371                  &amp; T1_SYNC_EXT_OFF              <span class="comment">// ne pas se synchroniser sur une horloge externe</span>
<a name="l00372"></a>00372         );
<a name="l00373"></a>00373 }<span class="comment">//end UserInit</span>
</pre></div>
<p>

<p>
<div class="dynheader">
Voici le graphe d'appel pour cette fonction :</div>
<div class="dynsection">
<p><center><img src="main_8c_655d748c28aad5b529f5826b50fe1251_cgraph.png" border="0" usemap="#main_8c_655d748c28aad5b529f5826b50fe1251_cgraph_map" alt=""></center>
<map name="main_8c_655d748c28aad5b529f5826b50fe1251_cgraph_map">
<area shape="rect" href="main_8c.html#d3060f9b061e802bba79e880c4484505" title="ResetSource() permet de connaitre l&#39;origine du dernier reset tout en réinitialisant..." alt="" coords="132,5,247,35"></map>
</div>

</div>
</div><p>
<a class="anchor" name="6647fa4207d49c8ba30d1609d0554791"></a><!-- doxytag: member="main.c::YourHighPriorityISRCode" ref="6647fa4207d49c8ba30d1609d0554791" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void YourHighPriorityISRCode           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8fc705d66a5ec3a6012cd0d4210ac8a9"></a><!-- doxytag: member="main.c::YourLowPriorityISRCode" ref="8fc705d66a5ec3a6012cd0d4210ac8a9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void YourLowPriorityISRCode           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Documentation des variables</h2>
<a class="anchor" name="663117df30d6ab9eef2e1280f4956ec3"></a><!-- doxytag: member="main.c::blinkStatusValid" ref="663117df30d6ab9eef2e1280f4956ec3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_generic_type_defs_8h.html#54d65c7fa62e62c9754371e42f5111b9">BOOL</a> <a class="el" href="main_8c.html#663117df30d6ab9eef2e1280f4956ec3">blinkStatusValid</a> = TRUE          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6d79583150d44af3d64e01a6c4e3abe0"></a><!-- doxytag: member="main.c::ReceivedDataBuffer" ref="6d79583150d44af3d64e01a6c4e3abe0" args="[64]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char <a class="el" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[64]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
INCLUDES. 
<p>
VARIABLES 
</div>
</div><p>
<a class="anchor" name="d1e58a5c30aa93b2b02ed582dc185fa5"></a><!-- doxytag: member="main.c::resetSource" ref="d1e58a5c30aa93b2b02ed582dc185fa5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="main_8c.html#d1e58a5c30aa93b2b02ed582dc185fa5">resetSource</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="cdc91cb16e31f2cb52e08df9cdf00b72"></a><!-- doxytag: member="main.c::ToSendDataBuffer" ref="cdc91cb16e31f2cb52e08df9cdf00b72" args="[64]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char <a class="el" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[64]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="92264d29f54b522e280bcad0d603e64a"></a><!-- doxytag: member="main.c::USBInHandle" ref="92264d29f54b522e280bcad0d603e64a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USB_HANDLE <a class="el" href="main_8c.html#92264d29f54b522e280bcad0d603e64a">USBInHandle</a> = 0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="fdba80f833058ed3f3776089fe23821c"></a><!-- doxytag: member="main.c::USBOutHandle" ref="fdba80f833058ed3f3776089fe23821c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USB_HANDLE <a class="el" href="main_8c.html#fdba80f833058ed3f3776089fe23821c">USBOutHandle</a> = 0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Généré le Sat Feb 14 20:09:21 2009 pour Carte capteurs par&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
