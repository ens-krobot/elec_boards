<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Carte d&#39;asservissement (bi): Référence du fichier main.c</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Généré par Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Page&nbsp;principale</span></a></li>
      <li><a href="pages.html"><span>Pages&nbsp;associées</span></a></li>
      <li><a href="classes.html"><span>Structures&nbsp;de&nbsp;données</span></a></li>
      <li class="current"><a href="files.html"><span>Fichiers</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Référence du fichier main.c</h1>Contient la fonction <a class="el" href="main_8c.html#840291bc02cba5474a4cb46a9b9566fe" title="VECTOR REMAPPING.">main()</a> du programme. <a href="#_details">Plus de détails...</a>
<p>
<code>#include &lt;timers.h&gt;</code><br>
<code>#include &lt;delays.h&gt;</code><br>
<code>#include &quot;<a class="el" href="_generic_type_defs_8h.html">GenericTypeDefs.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="_compiler_8h.html">Compiler.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="usb__config_8h.html">usb_config.h</a>&quot;</code><br>
<code>#include &quot;./USB/usb_device.h&quot;</code><br>
<code>#include &quot;./USB/usb.h&quot;</code><br>
<code>#include &quot;./USB/usb_function_hid.h&quot;</code><br>
<code>#include &quot;<a class="el" href="_hardware_profile_8h.html">HardwareProfile.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="eeprom_8h.html">eeprom.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="lm629_8h.html">lm629.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="motor_8h.html">motor.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="_pc_interface_8h.html">PcInterface.h</a>&quot;</code><br>

<p>
<div class="dynheader">
Graphe des dépendances par inclusion de main.c:</div>
<div class="dynsection">
<p><center><img src="main_8c__incl.png" border="0" usemap="#main.c_map" alt=""></center>
<map name="main.c_map">
<area shape="rect" href="_generic_type_defs_8h.html" title="GenericTypeDefs.h" alt="" coords="833,160,996,189"><area shape="rect" href="_compiler_8h.html" title="Compiler.h" alt="" coords="565,237,664,267"><area shape="rect" href="usb__config_8h.html" title="usb_config.h" alt="" coords="325,83,440,112"><area shape="rect" href="_hardware_profile_8h.html" title="Définitions spécifiques au PIC utilisé, pour l&#39;USB et les LEDs notamment." alt="" coords="1132,237,1284,267"><area shape="rect" href="eeprom_8h.html" title="Fonctions de lecture et d&#39;écriture avec l&#39;EEPROM du PIC." alt="" coords="211,83,301,112"><area shape="rect" href="lm629_8h.html" title="Gère l&#39;interface avec les circuits intégrés LM629." alt="" coords="1069,83,1147,112"><area shape="rect" href="motor_8h.html" title="Gère l&#39;interface avec la carte de puissance du moteur." alt="" coords="1071,160,1145,189"><area shape="rect" href="_pc_interface_8h.html" title="Fichier commun avec le programme hôte sur la carte mère (USB PC)." alt="" coords="1272,83,1392,112"></map>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Macros</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#e67a648431caa2ec7195221f2b8d6229">mLED_Both_Off</a>()&nbsp;&nbsp;&nbsp;{mLED_1_Off();mLED_2_Off();}</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#b5df00e3551e829a60428ebf67a47312">mLED_Both_On</a>()&nbsp;&nbsp;&nbsp;{mLED_1_On();mLED_2_On();}</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#70aacfac58a156dd6e65b13f75e57496">mLED_Only_1_On</a>()&nbsp;&nbsp;&nbsp;{mLED_1_On();mLED_2_Off();}</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#a36c2b39f7cd41729476b21894fbc019">mLED_Only_2_On</a>()&nbsp;&nbsp;&nbsp;{mLED_1_Off();mLED_2_On();}</td></tr>

<tr><td colspan="2"><br><h2>Fonctions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#42a6b0f3c41a4e5e1722aca3c3a4b4b5">BlinkUSBStatus</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gestion des LEDs selon l'état du périphérique USB.  <a href="#42a6b0f3c41a4e5e1722aca3c3a4b4b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#4f80a71f6079faf7617114a373a05017">InitializeSystem</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Centralise les routines d'initialisation.  <a href="#4f80a71f6079faf7617114a373a05017"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#ace5bc936ba3a482762863d6da13c941">ProcessIO</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fonction de traitement principale du programme.  <a href="#ace5bc936ba3a482762863d6da13c941"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#655d748c28aad5b529f5826b50fe1251">UserInit</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Routine d'initialisation utilisateur.  <a href="#655d748c28aad5b529f5826b50fe1251"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#6647fa4207d49c8ba30d1609d0554791">YourHighPriorityISRCode</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#8fc705d66a5ec3a6012cd0d4210ac8a9">YourLowPriorityISRCode</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#d3060f9b061e802bba79e880c4484505">ResetSource</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="main_8c.html#d3060f9b061e802bba79e880c4484505" title="ResetSource() permet de connaitre l&#39;origine du dernier reset tout en réinitialisant...">ResetSource()</a> permet de connaitre l'origine du dernier reset tout en réinitialisant correctement les registres pour le prochain reset.  <a href="#d3060f9b061e802bba79e880c4484505"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#840291bc02cba5474a4cb46a9b9566fe">main</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">VECTOR REMAPPING.  <a href="#840291bc02cba5474a4cb46a9b9566fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#24bc7f902cfd3ef505708c71099ca32a">USBCBSuspend</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call back that is invoked when a USB suspend is detected.  <a href="#24bc7f902cfd3ef505708c71099ca32a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#cb07fd7b59801b89093d5f5a375a1bb1">USBCBWakeFromSuspend</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is called when the USB interrupt bit is set In this example the interrupt is only used when the device goes to sleep when it receives a USB suspend command.  <a href="#cb07fd7b59801b89093d5f5a375a1bb1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#d39fa1008b49fb91555086e40710d573">USBCB_SOF_Handler</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The USB host sends out a SOF packet to full-speed devices every 1 ms.  <a href="#d39fa1008b49fb91555086e40710d573"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#e6717d77804b36ca26a975fd0bee6f01">USBCBErrorHandler</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The purpose of this callback is mainly for debugging during development.  <a href="#e6717d77804b36ca26a975fd0bee6f01"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#a1730f3cc119bd8eb04d9b55ebed56e6">USBCBCheckOtherReq</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When SETUP packets arrive from the host, some firmware must process the request and respond appropriately to fulfill the request.  <a href="#a1730f3cc119bd8eb04d9b55ebed56e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#85c176c4ca674eb30b43b414f6a66260">USBCBStdSetDscHandler</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="usb__device_8h.html#85c176c4ca674eb30b43b414f6a66260" title="The USBCBStdSetDscHandler() callback function is called when a SETUP, bRequest: SET_DESCRIPTOR...">USBCBStdSetDscHandler()</a> callback function is called when a SETUP, bRequest: SET_DESCRIPTOR request arrives.  <a href="#85c176c4ca674eb30b43b414f6a66260"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#e69da16b1f966a62cdd1831df5561cbf">USBCBInitEP</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is called when the device becomes initialized, which occurs after the host sends a SET_CONFIGURATION (wValue not = 0) request.  <a href="#e69da16b1f966a62cdd1831df5561cbf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#0349054fd83e147e1a88e375748e8caf">USBCBSendResume</a> (void)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a> [64]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a> [64]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">USB_HANDLE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#fdba80f833058ed3f3776089fe23821c">USBOutHandle</a> = 0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">USB_HANDLE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#92264d29f54b522e280bcad0d603e64a">USBInHandle</a> = 0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="_generic_type_defs_8h.html#54d65c7fa62e62c9754371e42f5111b9">BOOL</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#663117df30d6ab9eef2e1280f4956ec3">blinkStatusValid</a> = TRUE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#d1e58a5c30aa93b2b02ed582dc185fa5">resetSource</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">volatile unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#b4ee221e7a47440a79c5453a24ae8631">ms</a> = 0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">volatile unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8c.html#1ac96063dd8d639a297e0b06a32180fe">s</a> = 0</td></tr>

</table>
<hr><a name="_details"></a><h2>Description détaillée</h2>
Contient la fonction <a class="el" href="main_8c.html#840291bc02cba5474a4cb46a9b9566fe" title="VECTOR REMAPPING.">main()</a> du programme. 
<p>
<hr><h2>Documentation des macros</h2>
<a class="anchor" name="e67a648431caa2ec7195221f2b8d6229"></a><!-- doxytag: member="main.c::mLED_Both_Off" ref="e67a648431caa2ec7195221f2b8d6229" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mLED_Both_Off          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;{mLED_1_Off();mLED_2_Off();}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b5df00e3551e829a60428ebf67a47312"></a><!-- doxytag: member="main.c::mLED_Both_On" ref="b5df00e3551e829a60428ebf67a47312" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mLED_Both_On          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;{mLED_1_On();mLED_2_On();}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="70aacfac58a156dd6e65b13f75e57496"></a><!-- doxytag: member="main.c::mLED_Only_1_On" ref="70aacfac58a156dd6e65b13f75e57496" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mLED_Only_1_On          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;{mLED_1_On();mLED_2_Off();}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a36c2b39f7cd41729476b21894fbc019"></a><!-- doxytag: member="main.c::mLED_Only_2_On" ref="a36c2b39f7cd41729476b21894fbc019" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mLED_Only_2_On          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;{mLED_1_Off();mLED_2_On();}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Documentation des fonctions</h2>
<a class="anchor" name="42a6b0f3c41a4e5e1722aca3c3a4b4b5"></a><!-- doxytag: member="main.c::BlinkUSBStatus" ref="42a6b0f3c41a4e5e1722aca3c3a4b4b5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BlinkUSBStatus           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gestion des LEDs selon l'état du périphérique USB. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Les macros mLED se trouve dans <a class="el" href="_hardware_profile_8h.html" title="Définitions spécifiques au PIC utilisé, pour l&#39;USB et les LEDs notamment.">HardwareProfile.h</a> <br>
 USBDeviceState est déclarée et mis à jour dans <a class="el" href="usb__device_8c.html">usb_device.c</a>. </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00664"></a>00664 {
<a name="l00665"></a>00665     <span class="keyword">static</span> <a class="code" href="_generic_type_defs_8h.html#2b0e863dadf920709ec53d9088ee7c91">WORD</a> led_count=0;
<a name="l00666"></a>00666     
<a name="l00667"></a>00667     <span class="keywordflow">if</span>(led_count == 0)led_count = 10000U;
<a name="l00668"></a>00668     led_count--;
<a name="l00669"></a>00669 
<a name="l00670"></a>00670 <span class="preprocessor">    #define mLED_Both_Off()         {mLED_1_Off();mLED_2_Off();}</span>
<a name="l00671"></a>00671 <span class="preprocessor"></span><span class="preprocessor">    #define mLED_Both_On()          {mLED_1_On();mLED_2_On();}</span>
<a name="l00672"></a>00672 <span class="preprocessor"></span><span class="preprocessor">    #define mLED_Only_1_On()        {mLED_1_On();mLED_2_Off();}</span>
<a name="l00673"></a>00673 <span class="preprocessor"></span><span class="preprocessor">    #define mLED_Only_2_On()        {mLED_1_Off();mLED_2_On();}</span>
<a name="l00674"></a>00674 <span class="preprocessor"></span>
<a name="l00675"></a>00675     <span class="keywordflow">if</span>(<a class="code" href="usb__hal__pic18_8h.html#692643ef2e9ce498623a4f83b60952ce">USBSuspendControl</a> == 1)
<a name="l00676"></a>00676     {
<a name="l00677"></a>00677         <span class="keywordflow">if</span>(led_count==0)
<a name="l00678"></a>00678         {
<a name="l00679"></a>00679             <a class="code" href="_hardware_profile_8h.html#e9c56afc3ce3e0237f8bd50a58211935">mLED_1_Toggle</a>();
<a name="l00680"></a>00680             <span class="keywordflow">if</span>(<a class="code" href="_hardware_profile_8h.html#0ab4d6b68d300cfb30fe4fd70104c6fc">mGetLED_1</a>())
<a name="l00681"></a>00681             {
<a name="l00682"></a>00682                 <a class="code" href="_hardware_profile_8h.html#22f2591efef8efbc59ca78f23592628a">mLED_2_On</a>();
<a name="l00683"></a>00683             }
<a name="l00684"></a>00684             <span class="keywordflow">else</span>
<a name="l00685"></a>00685             {
<a name="l00686"></a>00686                 <a class="code" href="_hardware_profile_8h.html#a677cbc2658fcdcaa6c5205296fdb069">mLED_2_Off</a>();
<a name="l00687"></a>00687             }
<a name="l00688"></a>00688         }<span class="comment">//end if</span>
<a name="l00689"></a>00689     }
<a name="l00690"></a>00690     <span class="keywordflow">else</span>
<a name="l00691"></a>00691     {
<a name="l00692"></a>00692         <span class="keywordflow">if</span>(<a class="code" href="usb__device_8h.html#c6e6520c8c73c4456ea7194acff5bb71" title="EXTERNS.">USBDeviceState</a> == <a class="code" href="usb__device_8h.html#f93e6ca83071e0b9716689d05a26b0e0">DETACHED_STATE</a>)
<a name="l00693"></a>00693         {
<a name="l00694"></a>00694             <a class="code" href="main_8c.html#e67a648431caa2ec7195221f2b8d6229">mLED_Both_Off</a>();
<a name="l00695"></a>00695         }
<a name="l00696"></a>00696         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="usb__device_8h.html#c6e6520c8c73c4456ea7194acff5bb71" title="EXTERNS.">USBDeviceState</a> == <a class="code" href="usb__device_8h.html#485fb1d1dd0df89593f2dfdfcd4fcad1">ATTACHED_STATE</a>)
<a name="l00697"></a>00697         {
<a name="l00698"></a>00698             <a class="code" href="main_8c.html#b5df00e3551e829a60428ebf67a47312">mLED_Both_On</a>();
<a name="l00699"></a>00699         }
<a name="l00700"></a>00700         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="usb__device_8h.html#c6e6520c8c73c4456ea7194acff5bb71" title="EXTERNS.">USBDeviceState</a> == <a class="code" href="usb__device_8h.html#8dab51c2d5fd7f95bba6c9c10106b989">POWERED_STATE</a>)
<a name="l00701"></a>00701         {
<a name="l00702"></a>00702             <a class="code" href="main_8c.html#70aacfac58a156dd6e65b13f75e57496">mLED_Only_1_On</a>();
<a name="l00703"></a>00703         }
<a name="l00704"></a>00704         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="usb__device_8h.html#c6e6520c8c73c4456ea7194acff5bb71" title="EXTERNS.">USBDeviceState</a> == <a class="code" href="usb__device_8h.html#f93d7c80faa6ebd086460cde2d5dd27e">DEFAULT_STATE</a>)
<a name="l00705"></a>00705         {
<a name="l00706"></a>00706             <a class="code" href="main_8c.html#a36c2b39f7cd41729476b21894fbc019">mLED_Only_2_On</a>();
<a name="l00707"></a>00707         }
<a name="l00708"></a>00708         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="usb__device_8h.html#c6e6520c8c73c4456ea7194acff5bb71" title="EXTERNS.">USBDeviceState</a> == <a class="code" href="usb__device_8h.html#6bcec49c4751b6e53d47835eeca5651a">ADDRESS_STATE</a>)
<a name="l00709"></a>00709         {
<a name="l00710"></a>00710             <span class="keywordflow">if</span>(led_count == 0)
<a name="l00711"></a>00711             {
<a name="l00712"></a>00712                 <a class="code" href="_hardware_profile_8h.html#e9c56afc3ce3e0237f8bd50a58211935">mLED_1_Toggle</a>();
<a name="l00713"></a>00713                 <a class="code" href="_hardware_profile_8h.html#a677cbc2658fcdcaa6c5205296fdb069">mLED_2_Off</a>();
<a name="l00714"></a>00714             }<span class="comment">//end if</span>
<a name="l00715"></a>00715         }
<a name="l00716"></a>00716         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="usb__device_8h.html#c6e6520c8c73c4456ea7194acff5bb71" title="EXTERNS.">USBDeviceState</a> == <a class="code" href="usb__device_8h.html#2aba92e0aaf8ccae5d19fa4de46d0c8f">CONFIGURED_STATE</a>)
<a name="l00717"></a>00717         {
<a name="l00718"></a>00718             <span class="keywordflow">if</span>(led_count==0)
<a name="l00719"></a>00719             {
<a name="l00720"></a>00720                 <a class="code" href="_hardware_profile_8h.html#e9c56afc3ce3e0237f8bd50a58211935">mLED_1_Toggle</a>();
<a name="l00721"></a>00721                 <span class="keywordflow">if</span>(<a class="code" href="_hardware_profile_8h.html#0ab4d6b68d300cfb30fe4fd70104c6fc">mGetLED_1</a>())
<a name="l00722"></a>00722                 {
<a name="l00723"></a>00723                     <a class="code" href="_hardware_profile_8h.html#a677cbc2658fcdcaa6c5205296fdb069">mLED_2_Off</a>();
<a name="l00724"></a>00724                 }
<a name="l00725"></a>00725                 <span class="keywordflow">else</span>
<a name="l00726"></a>00726                 {
<a name="l00727"></a>00727                     <a class="code" href="_hardware_profile_8h.html#22f2591efef8efbc59ca78f23592628a">mLED_2_On</a>();
<a name="l00728"></a>00728                 }
<a name="l00729"></a>00729             }<span class="comment">//end if</span>
<a name="l00730"></a>00730         }<span class="comment">//end if(...)</span>
<a name="l00731"></a>00731     }<span class="comment">//end if(UCONbits.SUSPND...)</span>
<a name="l00732"></a>00732 
<a name="l00733"></a>00733 }<span class="comment">//end BlinkUSBStatus</span>
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4f80a71f6079faf7617114a373a05017"></a><!-- doxytag: member="main.c::InitializeSystem" ref="4f80a71f6079faf7617114a373a05017" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void InitializeSystem           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Centralise les routines d'initialisation. 
<p>
Toutes les routines d'initialisation USB sont appelées de cette fonction. La routine d'initialisation utilisateur doit également être appelée d'ici. <dl class="note" compact><dt><b>Note:</b></dt><dd>Cette fonction n'a pas à être modifiée, voir la fonction <a class="el" href="main_8c.html#655d748c28aad5b529f5826b50fe1251" title="Routine d&#39;initialisation utilisateur.">UserInit()</a>. </dd></dl>
<dl class="see" compact><dt><b>Voir également:</b></dt><dd><a class="el" href="usb__device_8h.html#16da2c36e4eb6a018808f99f291433ca" title="DECLARATIONS.">USBDeviceInit()</a> et <a class="el" href="main_8c.html#655d748c28aad5b529f5826b50fe1251" title="Routine d&#39;initialisation utilisateur.">UserInit()</a>. </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00320"></a>00320 {
<a name="l00321"></a>00321     ADCON1 |= 0x0F;                 <span class="comment">// Default all pins to digital</span>
<a name="l00322"></a>00322     
<a name="l00323"></a>00323 <span class="comment">//      The USB specifications require that USB peripheral devices must never source</span>
<a name="l00324"></a>00324 <span class="comment">//      current onto the Vbus pin.  Additionally, USB peripherals should not source</span>
<a name="l00325"></a>00325 <span class="comment">//      current on D+ or D- when the host/hub is not actively powering the Vbus line.</span>
<a name="l00326"></a>00326 <span class="comment">//      When designing a self powered (as opposed to bus powered) USB peripheral</span>
<a name="l00327"></a>00327 <span class="comment">//      device, the firmware should make sure not to turn on the USB module and D+</span>
<a name="l00328"></a>00328 <span class="comment">//      or D- pull up resistor unless Vbus is actively powered.  Therefore, the</span>
<a name="l00329"></a>00329 <span class="comment">//      firmware needs some means to detect when Vbus is being powered by the host.</span>
<a name="l00330"></a>00330 <span class="comment">//      A 5V tolerant I/O pin can be connected to Vbus (through a resistor), and</span>
<a name="l00331"></a>00331 <span class="comment">//      can be used to detect when Vbus is high (host actively powering), or low</span>
<a name="l00332"></a>00332 <span class="comment">//      (host is shut down or otherwise not supplying power).  The USB firmware</span>
<a name="l00333"></a>00333 <span class="comment">//      can then periodically poll this I/O pin to know when it is okay to turn on</span>
<a name="l00334"></a>00334 <span class="comment">//      the USB module/D+/D- pull up resistor.  When designing a purely bus powered</span>
<a name="l00335"></a>00335 <span class="comment">//      peripheral device, it is not possible to source current on D+ or D- when the</span>
<a name="l00336"></a>00336 <span class="comment">//      host is not actively providing power on Vbus. Therefore, implementing this</span>
<a name="l00337"></a>00337 <span class="comment">//      bus sense feature is optional.  This firmware can be made to use this bus</span>
<a name="l00338"></a>00338 <span class="comment">//      sense feature by making sure "USE_USB_BUS_SENSE_IO" has been defined in the</span>
<a name="l00339"></a>00339 <span class="comment">//      HardwareProfile.h file.    </span>
<a name="l00340"></a>00340 <span class="preprocessor">    #if defined(USE_USB_BUS_SENSE_IO)</span>
<a name="l00341"></a>00341 <span class="preprocessor"></span>    <a class="code" href="_hardware_profile_8h.html#232aeea381ca80764b4a70a64b0a658d">tris_usb_bus_sense</a> = <a class="code" href="_hardware_profile_8h.html#1a806e0533aa476bb6e62b7d22c93572" title="TRIS.">INPUT_PIN</a>; <span class="comment">// See HardwareProfile.h</span>
<a name="l00342"></a>00342 <span class="preprocessor">    #endif</span>
<a name="l00343"></a>00343 <span class="preprocessor"></span>    
<a name="l00344"></a>00344 <span class="comment">//      If the host PC sends a GetStatus (device) request, the firmware must respond</span>
<a name="l00345"></a>00345 <span class="comment">//      and let the host know if the USB peripheral device is currently bus powered</span>
<a name="l00346"></a>00346 <span class="comment">//      or self powered.  See chapter 9 in the official USB specifications for details</span>
<a name="l00347"></a>00347 <span class="comment">//      regarding this request.  If the peripheral device is capable of being both</span>
<a name="l00348"></a>00348 <span class="comment">//      self and bus powered, it should not return a hard coded value for this request.</span>
<a name="l00349"></a>00349 <span class="comment">//      Instead, firmware should check if it is currently self or bus powered, and</span>
<a name="l00350"></a>00350 <span class="comment">//      respond accordingly.  If the hardware has been configured like demonstrated</span>
<a name="l00351"></a>00351 <span class="comment">//      on the PICDEM FS USB Demo Board, an I/O pin can be polled to determine the</span>
<a name="l00352"></a>00352 <span class="comment">//      currently selected power source.  On the PICDEM FS USB Demo Board, "RA2" </span>
<a name="l00353"></a>00353 <span class="comment">//      is used for     this purpose.  If using this feature, make sure "USE_SELF_POWER_SENSE_IO"</span>
<a name="l00354"></a>00354 <span class="comment">//      has been defined in HardwareProfile.h, and that an appropriate I/O pin has been mapped</span>
<a name="l00355"></a>00355 <span class="comment">//      to it in HardwareProfile.h.</span>
<a name="l00356"></a>00356 <span class="preprocessor">    #if defined(USE_SELF_POWER_SENSE_IO)</span>
<a name="l00357"></a>00357 <span class="preprocessor"></span>    <a class="code" href="_hardware_profile_8h.html#ba35cc821d7d3d1c490ce9778e80f363">tris_self_power</a> = <a class="code" href="_hardware_profile_8h.html#1a806e0533aa476bb6e62b7d22c93572" title="TRIS.">INPUT_PIN</a>;        <span class="comment">// See HardwareProfile.h</span>
<a name="l00358"></a>00358 <span class="preprocessor">    #endif</span>
<a name="l00359"></a>00359 <span class="preprocessor"></span>    
<a name="l00360"></a>00360     <a class="code" href="usb__device_8h.html#16da2c36e4eb6a018808f99f291433ca" title="DECLARATIONS.">USBDeviceInit</a>();    <span class="comment">//usb_device.c.  Initializes USB module SFRs and firmware</span>
<a name="l00361"></a>00361                                         <span class="comment">//variables to known states.</span>
<a name="l00362"></a>00362     <a class="code" href="main_8c.html#655d748c28aad5b529f5826b50fe1251" title="Routine d&amp;#39;initialisation utilisateur.">UserInit</a>();
<a name="l00363"></a>00363 
<a name="l00364"></a>00364 }<span class="comment">//end InitializeSystem</span>
</pre></div>
<p>

<p>
<div class="dynheader">
Voici le graphe d'appel pour cette fonction :</div>
<div class="dynsection">
<p><center><img src="main_8c_4f80a71f6079faf7617114a373a05017_cgraph.png" border="0" usemap="#main_8c_4f80a71f6079faf7617114a373a05017_cgraph_map" alt=""></center>
<map name="main_8c_4f80a71f6079faf7617114a373a05017_cgraph_map">
<area shape="rect" href="usb__device_8h.html#16da2c36e4eb6a018808f99f291433ca" title="DECLARATIONS." alt="" coords="191,5,316,35"><area shape="rect" href="main_8c.html#655d748c28aad5b529f5826b50fe1251" title="Routine d&#39;initialisation utilisateur." alt="" coords="215,59,292,88"><area shape="rect" href="usb__device_8h.html#42d85f637ff9d3615ca3090303008adc" title="USBClearInterruptFlag" alt="" coords="367,5,551,35"><area shape="rect" href="main_8c.html#d3060f9b061e802bba79e880c4484505" title="ResetSource() permet de connaitre l&#39;origine du dernier reset tout en réinitialisant..." alt="" coords="401,59,516,88"></map>
</div>

</div>
</div><p>
<a class="anchor" name="840291bc02cba5474a4cb46a9b9566fe"></a><!-- doxytag: member="main.c::main" ref="840291bc02cba5474a4cb46a9b9566fe" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
VECTOR REMAPPING. 
<p>
DECLARATIONS Main program entry point. <div class="fragment"><pre class="fragment"><a name="l00276"></a>00276 {
<a name="l00277"></a>00277 <span class="comment">//    //This can be used for user entry into the bootloader  </span>
<a name="l00278"></a>00278 <span class="comment">//    #if defined(__C30__) </span>
<a name="l00279"></a>00279 <span class="comment">//        mInitSwitch2();</span>
<a name="l00280"></a>00280 <span class="comment">//        if(sw2 == 0)</span>
<a name="l00281"></a>00281 <span class="comment">//        {</span>
<a name="l00282"></a>00282 <span class="comment">//            EnterBootloader();</span>
<a name="l00283"></a>00283 <span class="comment">//        }</span>
<a name="l00284"></a>00284 <span class="comment">//    #endif</span>
<a name="l00285"></a>00285 
<a name="l00286"></a>00286     <a class="code" href="main_8c.html#4f80a71f6079faf7617114a373a05017" title="Centralise les routines d&amp;#39;initialisation.">InitializeSystem</a>();
<a name="l00287"></a>00287 
<a name="l00288"></a>00288     <span class="keywordflow">while</span>(1)
<a name="l00289"></a>00289     {
<a name="l00290"></a>00290                 <span class="comment">// Check bus status and service USB interrupts.</span>
<a name="l00291"></a>00291         <a class="code" href="usb__device_8h.html#f35807553af66eab5b5d459fa13b274e" title="PUBLIC PROTOTYPES.">USBDeviceTasks</a>(); <span class="comment">// Interrupt or polling method.  If using polling, must call</span>
<a name="l00292"></a>00292                                           <span class="comment">// this function periodically.  This function will take care</span>
<a name="l00293"></a>00293                                           <span class="comment">// of processing and responding to SETUP transactions </span>
<a name="l00294"></a>00294                                           <span class="comment">// (such as during the enumeration process when you first</span>
<a name="l00295"></a>00295                                           <span class="comment">// plug in).  USB hosts require that USB devices should accept</span>
<a name="l00296"></a>00296                                           <span class="comment">// and process SETUP packets in a timely fashion.  Therefore,</span>
<a name="l00297"></a>00297                                           <span class="comment">// when using polling, this function should be called </span>
<a name="l00298"></a>00298                                           <span class="comment">// frequently (such as once about every 100 microseconds) at any</span>
<a name="l00299"></a>00299                                           <span class="comment">// time that a SETUP packet might reasonably be expected to</span>
<a name="l00300"></a>00300                                           <span class="comment">// be sent by the host to your device.  In most cases, the</span>
<a name="l00301"></a>00301                                           <span class="comment">// USBDeviceTasks() function does not take very long to</span>
<a name="l00302"></a>00302                                           <span class="comment">// execute (~50 instruction cycles) before it returns.</span>
<a name="l00303"></a>00303                                   
<a name="l00304"></a>00304 
<a name="l00305"></a>00305                 <span class="comment">// Application-specific tasks.</span>
<a name="l00306"></a>00306                 <span class="comment">// Application related code may be added here, or in the ProcessIO() function.</span>
<a name="l00307"></a>00307         <a class="code" href="main_8c.html#ace5bc936ba3a482762863d6da13c941" title="Fonction de traitement principale du programme.">ProcessIO</a>();        
<a name="l00308"></a>00308     }<span class="comment">//end while</span>
<a name="l00309"></a>00309 }<span class="comment">//end main</span>
</pre></div>
<p>

<p>
<div class="dynheader">
Voici le graphe d'appel pour cette fonction :</div>
<div class="dynsection">
<p><center><img src="main_8c_840291bc02cba5474a4cb46a9b9566fe_cgraph.png" border="0" usemap="#main_8c_840291bc02cba5474a4cb46a9b9566fe_cgraph_map" alt=""></center>
<map name="main_8c_840291bc02cba5474a4cb46a9b9566fe_cgraph_map">
<area shape="rect" href="main_8c.html#4f80a71f6079faf7617114a373a05017" title="Centralise les routines d&#39;initialisation." alt="" coords="116,989,249,1019"><area shape="rect" href="main_8c.html#ace5bc936ba3a482762863d6da13c941" title="Fonction de traitement principale du programme." alt="" coords="133,1432,232,1461"><area shape="rect" href="usb__device_8h.html#f35807553af66eab5b5d459fa13b274e" title="PUBLIC PROTOTYPES." alt="" coords="109,539,256,568"><area shape="rect" href="usb__device_8h.html#16da2c36e4eb6a018808f99f291433ca" title="DECLARATIONS." alt="" coords="367,963,492,992"><area shape="rect" href="main_8c.html#655d748c28aad5b529f5826b50fe1251" title="Routine d&#39;initialisation utilisateur." alt="" coords="391,1016,468,1045"><area shape="rect" href="usb__device_8h.html#42d85f637ff9d3615ca3090303008adc" title="USBClearInterruptFlag" alt="" coords="623,856,807,885"><area shape="rect" href="main_8c.html#d3060f9b061e802bba79e880c4484505" title="ResetSource() permet de connaitre l&#39;origine du dernier reset tout en réinitialisant..." alt="" coords="657,1016,772,1045"><area shape="rect" href="main_8c.html#42a6b0f3c41a4e5e1722aca3c3a4b4b5" title="Gestion des LEDs selon l&#39;état du périphérique USB." alt="" coords="363,1539,496,1568"><area shape="rect" href="motor_8c.html#189f66fb3cf35d131837dd26974a3b8c" title="Active un ou plusieurs axe(s) moteur(s)." alt="" coords="375,1592,484,1621"><area shape="rect" href="motor_8c.html#f28faafd0d5603bd1dfabbcd9731e0d9" title="Récupère la mesure du courant dans un moteur." alt="" coords="388,1645,471,1675"><area shape="rect" href="lm629_8c.html#49e97890e5c9ab4f6fca2ba9ce33c885" title="Initialise les 2 LMs avec les paramètres par défaut." alt="" coords="393,1328,465,1357"><area shape="rect" href="lm629_8c.html#6fa7a38bcd0eeb3fb9c107702f73f516" title="Envoie une commande à/aux LM(s)." alt="" coords="1095,1224,1223,1253"><area shape="rect" href="lm629_8c.html#e3ef6f2f44349bc4e6af34671b6aa4aa" title="Lire un bit d&#39;état du LM." alt="" coords="656,1656,773,1685"><area shape="rect" href="lm629_8c.html#928f6fe98ffaaa8f72282688bcc8d1cd" title="Indique si la dernière trajectoire est terminée." alt="" coords="365,1699,493,1728"><area shape="rect" href="lm629_8c.html#f53f9dcb4f2401d3b013a07e63f8762d" title="Recule." alt="" coords="649,1276,780,1305"><area shape="rect" href="lm629_8c.html#bdba60aec4c9ae15e242fe1824ca4e5b" title="Avance." alt="" coords="655,1223,775,1252"><area shape="rect" href="lm629_8c.html#ec750313f79234101e43e09e3083b947" title="Lire un mot envoyé par le LM (un mot = 2 octets = 16 bits)." alt="" coords="1095,1377,1223,1407"><area shape="rect" href="eeprom_8c.html#23c79775828a6c484c66ba66b42ca847" title="Lit dans l&#39;EEPROM du PIC." alt="" coords="365,1432,493,1461"><area shape="rect" href="eeprom_8c.html#fd48dcf153304aa7a2726ca1b717ab14" title="Ecrit dans l&#39;EEPROM du PIC." alt="" coords="364,1485,495,1515"><area shape="rect" href="lm629_8c.html#18cecfad364f842e6a71efbd459857df" title="Initialise un LM, c&#39;est&#45;à&#45;dire :Contrôle que le RESET s&#39;est fait correctement..." alt="" coords="683,1329,747,1359"><area shape="rect" href="lm629_8c.html#87c455cfb4cbd87a3de45fd9f38a1b45" title="Lire l&#39;état d&#39;un LM." alt="" coords="1109,1431,1208,1460"><area shape="rect" href="lm629_8c.html#3917d5827bfa6cc17f4e1a47ff073248" title="Reset les bits d&#39;interruption du/des LM(s)." alt="" coords="901,1277,1019,1307"><area shape="rect" href="lm629_8c.html#151178ea603ed04beaa1ba4151496878" title="Envoie un mot au LM (un mot = 2 octets = 16 bits)." alt="" coords="1093,1277,1224,1307"><area shape="rect" href="lm629_8c.html#6c314f24d23be4191ad86293c9a5fecc" title="Change la direction du BUS de donnée." alt="" coords="1429,1328,1576,1357"><area shape="rect" href="lm629_8c.html#89cbdf56bf6a423f871db85d9b25b7ba" title="Attends que le ou les LM(s) ne soient plus occupés." alt="" coords="1273,1328,1380,1357"><area shape="rect" href="lm629_8c.html#50cb02e459a813bf1d2d14a80d905a41" title="Programme une nouvelle position à atteindre." alt="" coords="907,1224,1013,1253"><area shape="rect" href="lm629_8c.html#adb0186b6cbfbfe2f37d6e5d64284499" title="Démarre la trajectoire programmée." alt="" coords="935,1171,985,1200"><area shape="rect" href="usb__otg_8h.html#c5d1852c92a2364bf541966638962f42" title="USB_OTGEventHandler" alt="" coords="333,112,525,141"><area shape="rect" href="usb__device_8h.html#d39fa1008b49fb91555086e40710d573" title="The USB host sends out a SOF packet to full&#45;speed devices every 1 ms." alt="" coords="337,165,521,195"><area shape="rect" href="usb__device_8h.html#e6717d77804b36ca26a975fd0bee6f01" title="The purpose of this callback is mainly for debugging during development." alt="" coords="344,219,515,248"><area shape="rect" href="usb__device_8h.html#e5d35bef641e59de9a7279d639cc10b6" title="USBCtrlEPService" alt="" coords="352,59,507,88"><area shape="rect" href="usb__otg_8h.html#0e4aa57c5361e842d6ff6892aab573b6" title="USBOTGClearSRPReady" alt="" coords="327,325,532,355"><area shape="rect" href="usb__otg_8h.html#d4bbe76141dea5928c75ce40938717e1" title="USBOTGClearSRPTimeOutFlag" alt="" coords="304,379,555,408"><area shape="rect" href="usb__otg_8h.html#f436961125c7e07df2081b53e4b37001" title="USBOTGDeactivateHnp" alt="" coords="333,432,525,461"><area shape="rect" href="usb__otg_8h.html#d078cd43132c6251de3865b19b8de4cb" title="USBOTGDisableHnp" alt="" coords="344,485,515,515"><area shape="rect" href="usb__otg_8h.html#78ca11f637dbda5615015004b1af7a43" title="USBOTGGetSRPTimeOutFlag" alt="" coords="312,539,547,568"><area shape="rect" href="usb__otg_8h.html#1821d7229191e748ee716d497b14e5a2" title="USBOTGInitialize" alt="" coords="356,592,503,621"><area shape="rect" href="usb__otg_8h.html#f06c63d6f822660c4a2a3a52c29fd257" title="USBOTGIsSRPTimeOutExpired" alt="" coords="305,645,553,675"><area shape="rect" href="usb__otg_8h.html#6b7e526fa731f878145d8a05ac1afc02" title="USBOTGSelectRole" alt="" coords="348,699,511,728"><area shape="rect" href="usb__otg_8h.html#074a26ffca9ba1473076efdb826d1771" title="USBOTGSRPIsReady" alt="" coords="340,752,519,781"><area shape="rect" href="usb__device_8h.html#f7fca92a339183ae8f268bb8c3ca4e7e" title="USBStallHandler" alt="" coords="360,856,499,885"><area shape="rect" href="usb__device_8h.html#1e0966febda8e01d2e4e58ceb42dd46a" title="USBSuspend" alt="" coords="371,909,488,939"><area shape="rect" href="usb__device_8h.html#9104bea8c7f5045558f6cc5721e7455f" title="USBWakeFromSuspend" alt="" coords="329,272,529,301"><area shape="rect" href="usb__device_8h.html#8bfda535b2c9273a24983c1799f3fb42" title="USBCtrlTrfInHandler" alt="" coords="631,112,799,141"><area shape="rect" href="usb__device_8h.html#d30a9aeba644af617b04c45333fc5125" title="USBCtrlTrfOutHandler" alt="" coords="625,5,804,35"><area shape="rect" href="usb__device_8h.html#4fd82120d0ce7ac5df27574b2fcd2b8f" title="USBCtrlTrfSetupHandler" alt="" coords="616,59,813,88"><area shape="rect" href="usb__device_8h.html#6dde221e5c27eb18f62335810c830630" title="USBCtrlTrfTxService" alt="" coords="875,112,1045,141"><area shape="rect" href="usb__device_8h.html#24bc7f902cfd3ef505708c71099ca32a" title="Section: CALLBACKS." alt="" coords="644,909,785,939"><area shape="rect" href="usb__device_8h.html#cb07fd7b59801b89093d5f5a375a1bb1" title="This function is called when the USB interrupt bit is set In this example the interrupt..." alt="" coords="604,272,825,301"></map>
</div>

</div>
</div><p>
<a class="anchor" name="ace5bc936ba3a482762863d6da13c941"></a><!-- doxytag: member="main.c::ProcessIO" ref="ace5bc936ba3a482762863d6da13c941" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProcessIO           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fonction de traitement principale du programme. 
<p>
<div class="fragment"><pre class="fragment"><a name="l00423"></a>00423                      {   
<a name="l00424"></a>00424         <a class="code" href="_generic_type_defs_8h.html#4ae1dab0fb4b072a66584546209e7d58">BYTE</a> eeprom;
<a name="l00425"></a>00425         <span class="keyword">static</span> <span class="keywordtype">char</span> state = 0;
<a name="l00426"></a>00426         <a class="code" href="union___d_w_o_r_d___v_a_l.html">DWORD_VAL</a> dword;
<a name="l00427"></a>00427 
<a name="l00428"></a>00428     <span class="comment">//Blink the LEDs according to the USB device status</span>
<a name="l00429"></a>00429     <span class="keywordflow">if</span>(<a class="code" href="main_8c.html#663117df30d6ab9eef2e1280f4956ec3">blinkStatusValid</a>) {
<a name="l00430"></a>00430         <a class="code" href="main_8c.html#42a6b0f3c41a4e5e1722aca3c3a4b4b5" title="Gestion des LEDs selon l&amp;#39;état du périphérique USB.">BlinkUSBStatus</a>();
<a name="l00431"></a>00431     }
<a name="l00432"></a>00432 
<a name="l00433"></a>00433     <span class="comment">// User Application USB tasks</span>
<a name="l00434"></a>00434     <span class="keywordflow">if</span>((<a class="code" href="usb__device_8h.html#c6e6520c8c73c4456ea7194acff5bb71" title="EXTERNS.">USBDeviceState</a> &lt; <a class="code" href="usb__device_8h.html#2aba92e0aaf8ccae5d19fa4de46d0c8f">CONFIGURED_STATE</a>)||(<a class="code" href="usb__hal__pic18_8h.html#692643ef2e9ce498623a4f83b60952ce">USBSuspendControl</a>==1)) <span class="keywordflow">return</span>;
<a name="l00435"></a>00435 
<a name="l00436"></a>00436         <span class="keywordflow">if</span> (state &gt; 0) {
<a name="l00437"></a>00437                 <span class="keywordflow">switch</span> (state) {
<a name="l00438"></a>00438                         <span class="keywordflow">case</span> 1:
<a name="l00439"></a>00439                                 <a class="code" href="motor_8c.html#189f66fb3cf35d131837dd26974a3b8c" title="Active un ou plusieurs axe(s) moteur(s).">enableMotor</a>(<a class="code" href="motor_8h.html#327dd27b4e08cc7c38cb5d48d55dac7c" title="Sélection des 2 moteurs simultanément.">MOTOR_BOTH</a>);
<a name="l00440"></a>00440         
<a name="l00441"></a>00441                                 <span class="keywordflow">if</span> (<a class="code" href="lm629_8c.html#49e97890e5c9ab4f6fca2ba9ce33c885" title="Initialise les 2 LMs avec les paramètres par défaut.">initLMs</a>())
<a name="l00442"></a>00442                                         state = 2;
<a name="l00443"></a>00443                                 <span class="keywordflow">else</span>
<a name="l00444"></a>00444                                         state = -1;
<a name="l00445"></a>00445                         <span class="keywordflow">break</span>;
<a name="l00446"></a>00446 
<a name="l00447"></a>00447                         <span class="keywordflow">case</span> 2:
<a name="l00448"></a>00448                                 <a class="code" href="lm629_8c.html#bdba60aec4c9ae15e242fe1824ca4e5b" title="Avance.">moveForward</a>(1000, 2000, 800);                   <span class="comment">// Avance de 1 m</span>
<a name="l00449"></a>00449                                 state = 3;
<a name="l00450"></a>00450                         <span class="keywordflow">break</span>;
<a name="l00451"></a>00451 
<a name="l00452"></a>00452                         <span class="keywordflow">case</span> 3:
<a name="l00453"></a>00453                                 <span class="keywordflow">if</span> (<a class="code" href="lm629_8c.html#928f6fe98ffaaa8f72282688bcc8d1cd" title="Indique si la dernière trajectoire est terminée.">isTrajComplete</a>()) {
<a name="l00454"></a>00454                                         <a class="code" href="lm629_8c.html#f53f9dcb4f2401d3b013a07e63f8762d" title="Recule.">moveBackward</a>(1000, 200, 150);           <span class="comment">// Recule de 1 m (à vitesse réduite)</span>
<a name="l00455"></a>00455                                         state = 4;
<a name="l00456"></a>00456                                 }
<a name="l00457"></a>00457                         <span class="keywordflow">break</span>;
<a name="l00458"></a>00458 
<a name="l00459"></a>00459                         <span class="keywordflow">case</span> 4:
<a name="l00460"></a>00460                                 <span class="keywordflow">if</span> (<a class="code" href="lm629_8c.html#928f6fe98ffaaa8f72282688bcc8d1cd" title="Indique si la dernière trajectoire est terminée.">isTrajComplete</a>()) {
<a name="l00461"></a>00461                                         <a class="code" href="lm629_8c.html#bdba60aec4c9ae15e242fe1824ca4e5b" title="Avance.">moveForward</a>(500, 1000, 1000);           <span class="comment">// Avance de 50 cm</span>
<a name="l00462"></a>00462                                         state = 5;
<a name="l00463"></a>00463                                 }
<a name="l00464"></a>00464                         <span class="keywordflow">break</span>;
<a name="l00465"></a>00465 
<a name="l00466"></a>00466                         <span class="keywordflow">case</span> 5:
<a name="l00467"></a>00467                                 <span class="keywordflow">if</span> (<a class="code" href="lm629_8c.html#928f6fe98ffaaa8f72282688bcc8d1cd" title="Indique si la dernière trajectoire est terminée.">isTrajComplete</a>()) {
<a name="l00468"></a>00468                                         <span class="keywordflow">if</span> (!<a class="code" href="usb__function__hid_8h.html#1e12a1ffede90ef301604c507344c427">HIDTxHandleBusy</a>(<a class="code" href="main_8c.html#92264d29f54b522e280bcad0d603e64a">USBInHandle</a>)) {
<a name="l00469"></a>00469                                                 <a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[0] = <a class="code" href="_pc_interface_8h.html#5e7e23f7dd514b640eddf3ac0c367f45" title="Envoyer du texte.">CMD_SEND</a>;
<a name="l00470"></a>00470                                                 <a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[1] = <span class="charliteral">'\0'</span>;
<a name="l00471"></a>00471                                                 <a class="code" href="_compiler_8h.html#5e42f7bf7b2e4f4e8d9e79a02a3e0704">strcatpgm2ram</a>((<span class="keywordtype">char</span> *) &amp;<a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[0], (<span class="keyword">const</span> rom far <span class="keywordtype">char</span> *) <span class="stringliteral">"Trajectoire complétée"</span>);
<a name="l00472"></a>00472         
<a name="l00473"></a>00473                                                 <a class="code" href="main_8c.html#92264d29f54b522e280bcad0d603e64a">USBInHandle</a> = <a class="code" href="usb__function__hid_8h.html#83ec8b61af7d69c3e52fc9e92949764b">HIDTxPacket</a>(<a class="code" href="usb__config_8h.html#c4093f7479aadbd1a364d8caf7ac0fe7">HID_EP</a>, (<a class="code" href="_generic_type_defs_8h.html#4ae1dab0fb4b072a66584546209e7d58">BYTE</a>*) &amp;ToSendDataBuffer, 64);
<a name="l00474"></a>00474 
<a name="l00475"></a>00475                                                 <span class="comment">// disableMotor(MOTOR_BOTH);</span>
<a name="l00476"></a>00476                                                 state = 0;
<a name="l00477"></a>00477                                         }
<a name="l00478"></a>00478                                 }
<a name="l00479"></a>00479                         <span class="keywordflow">break</span>;
<a name="l00480"></a>00480 
<a name="l00481"></a>00481                         <span class="keywordflow">case</span> -1:
<a name="l00482"></a>00482                                 <span class="keywordflow">if</span> (!<a class="code" href="usb__function__hid_8h.html#1e12a1ffede90ef301604c507344c427">HIDTxHandleBusy</a>(<a class="code" href="main_8c.html#92264d29f54b522e280bcad0d603e64a">USBInHandle</a>)) {
<a name="l00483"></a>00483                                         <a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[0] = <a class="code" href="_pc_interface_8h.html#5e7e23f7dd514b640eddf3ac0c367f45" title="Envoyer du texte.">CMD_SEND</a>;
<a name="l00484"></a>00484                                         <a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[1] = <span class="charliteral">'\0'</span>;
<a name="l00485"></a>00485                                         <a class="code" href="_compiler_8h.html#5e42f7bf7b2e4f4e8d9e79a02a3e0704">strcatpgm2ram</a>((<span class="keywordtype">char</span> *) &amp;<a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[0], (<span class="keyword">const</span> rom far <span class="keywordtype">char</span> *) <span class="stringliteral">"Erreur de commande sur les LMs"</span>);
<a name="l00486"></a>00486         
<a name="l00487"></a>00487                                         <a class="code" href="main_8c.html#92264d29f54b522e280bcad0d603e64a">USBInHandle</a> = <a class="code" href="usb__function__hid_8h.html#83ec8b61af7d69c3e52fc9e92949764b">HIDTxPacket</a>(<a class="code" href="usb__config_8h.html#c4093f7479aadbd1a364d8caf7ac0fe7">HID_EP</a>, (<a class="code" href="_generic_type_defs_8h.html#4ae1dab0fb4b072a66584546209e7d58">BYTE</a>*) &amp;ToSendDataBuffer, 64);
<a name="l00488"></a>00488                                         state = 0;
<a name="l00489"></a>00489                                 }
<a name="l00490"></a>00490                         <span class="keywordflow">break</span>;
<a name="l00491"></a>00491 
<a name="l00492"></a>00492                         <span class="keywordflow">default</span>:
<a name="l00493"></a>00493                                 state = 0;
<a name="l00494"></a>00494                 }
<a name="l00495"></a>00495 
<a name="l00496"></a>00496                 <span class="keywordflow">if</span> (<a class="code" href="lm629_8c.html#e3ef6f2f44349bc4e6af34671b6aa4aa" title="Lire un bit d&amp;#39;état du LM.">readStatusBit</a>(<a class="code" href="motor_8h.html#9eff471d17bc68f18b14ff75f23aa3bc" title="Sélection du moteur de droite (moteur 1).">MOTOR_RIGHT</a>, <a class="code" href="lm629_8h.html#82baca2a5876592ab43532578564a601" title="Command Error [Interrupt].">LM_COMMAND_ERROR</a>) || <a class="code" href="lm629_8c.html#e3ef6f2f44349bc4e6af34671b6aa4aa" title="Lire un bit d&amp;#39;état du LM.">readStatusBit</a>(<a class="code" href="motor_8h.html#0e2d750df9008232cafa398d2424b778" title="Sélection du moteur de gauche (moteur 2).">MOTOR_LEFT</a>, <a class="code" href="lm629_8h.html#82baca2a5876592ab43532578564a601" title="Command Error [Interrupt].">LM_COMMAND_ERROR</a>))
<a name="l00497"></a>00497                         state = -1;
<a name="l00498"></a>00498         }
<a name="l00499"></a>00499 
<a name="l00500"></a>00500     <span class="keywordflow">if</span>(!<a class="code" href="usb__function__hid_8h.html#21371467f39c3b935773bde1c81c768d">HIDRxHandleBusy</a>(<a class="code" href="main_8c.html#fdba80f833058ed3f3776089fe23821c">USBOutHandle</a>)) {
<a name="l00501"></a>00501         <span class="keywordflow">switch</span> (<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[0]) {
<a name="l00502"></a>00502                         <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#fe1dd8546b0a8cd30b19a0229205c8df" title="Reset du PIC.">CMD_RESET</a>:
<a name="l00503"></a>00503                                 <span class="comment">// Reset</span>
<a name="l00504"></a>00504                                 Reset();
<a name="l00505"></a>00505                         <span class="keywordflow">break</span>;
<a name="l00506"></a>00506 
<a name="l00507"></a>00507                         <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#d005dfb346cb7a56a2450a33f9cec621" title="Reset du PIC en mode bootloader.">CMD_BOOTLOADER</a>:
<a name="l00508"></a>00508                                 <span class="comment">// Reset sur le bootloader</span>
<a name="l00509"></a>00509                                 eeprom = <a class="code" href="eeprom_8c.html#23c79775828a6c484c66ba66b42ca847" title="Lit dans l&amp;#39;EEPROM du PIC.">ReadEEPROM</a>(0x00);
<a name="l00510"></a>00510                                 eeprom|= 0b1;
<a name="l00511"></a>00511                                 <a class="code" href="eeprom_8c.html#fd48dcf153304aa7a2726ca1b717ab14" title="Ecrit dans l&amp;#39;EEPROM du PIC.">WriteEEPROM</a>(0x00, eeprom);
<a name="l00512"></a>00512                                 Reset();
<a name="l00513"></a>00513                         <span class="keywordflow">break</span>;
<a name="l00514"></a>00514 
<a name="l00515"></a>00515                         <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#39f82f93564bba7925fd849ce7967a2b" title="Obtenir une information.">CMD_GET</a>:
<a name="l00516"></a>00516                                 <span class="keywordflow">if</span> (!<a class="code" href="usb__function__hid_8h.html#1e12a1ffede90ef301604c507344c427">HIDTxHandleBusy</a>(<a class="code" href="main_8c.html#92264d29f54b522e280bcad0d603e64a">USBInHandle</a>)) {
<a name="l00517"></a>00517                                         <a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[0] = <a class="code" href="_pc_interface_8h.html#46fec82bccecfa46f11015c448c79fe7" title="Réponse à une commande.">CMD_RESPOND</a>;
<a name="l00518"></a>00518 
<a name="l00519"></a>00519                                         <span class="keywordflow">switch</span> (<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[1]) {
<a name="l00520"></a>00520                                                 <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#1d93585646df2b625c747dce1d612831" title="Demande au PIC la source du Reset.">GET_RESET_SOURCE</a>:
<a name="l00521"></a>00521                                                         <a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[1] = <a class="code" href="main_8c.html#d1e58a5c30aa93b2b02ed582dc185fa5">resetSource</a>;
<a name="l00522"></a>00522                                                 <span class="keywordflow">break</span>;
<a name="l00523"></a>00523 
<a name="l00524"></a>00524                                                 <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#35512d717451a9b2fed3ee5a7ea996b3" title="Demande au PIC des infos sur le firmware.">GET_FIRMWARE_BUILD</a>:
<a name="l00525"></a>00525                                                         <a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[1] = <span class="charliteral">'\0'</span>;
<a name="l00526"></a>00526                                                         <a class="code" href="_compiler_8h.html#5e42f7bf7b2e4f4e8d9e79a02a3e0704">strcatpgm2ram</a>((<span class="keywordtype">char</span> *) &amp;<a class="code" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[0], (<span class="keyword">const</span> rom far <span class="keywordtype">char</span> *) <span class="stringliteral">"Carte d'asserv. 1.0\r\nOlivier BICHLER\r\n"</span>);
<a name="l00527"></a>00527                                                         <a class="code" href="_compiler_8h.html#5e42f7bf7b2e4f4e8d9e79a02a3e0704">strcatpgm2ram</a>((<span class="keywordtype">char</span> *) &amp;ToSendDataBuffer[0], (<span class="keyword">const</span> rom far <span class="keywordtype">char</span> *) __DATE__);
<a name="l00528"></a>00528                                                         <a class="code" href="_compiler_8h.html#5e42f7bf7b2e4f4e8d9e79a02a3e0704">strcatpgm2ram</a>((<span class="keywordtype">char</span> *) &amp;ToSendDataBuffer[0], (<span class="keyword">const</span> rom far <span class="keywordtype">char</span> *) <span class="stringliteral">" "</span>);
<a name="l00529"></a>00529                                                         <a class="code" href="_compiler_8h.html#5e42f7bf7b2e4f4e8d9e79a02a3e0704">strcatpgm2ram</a>((<span class="keywordtype">char</span> *) &amp;ToSendDataBuffer[0], (<span class="keyword">const</span> rom far <span class="keywordtype">char</span> *) __TIME__);
<a name="l00530"></a>00530                                                 <span class="keywordflow">break</span>;
<a name="l00531"></a>00531 
<a name="l00532"></a>00532                                                 <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#12e2decd6772ba16d9da85602bb09407" title="Demande la config TRIS des ports du PIC.">GET_PORTS_CONFIG</a>:
<a name="l00533"></a>00533                                                         ToSendDataBuffer[1] = TRISA;
<a name="l00534"></a>00534                                                         ToSendDataBuffer[2] = TRISB;
<a name="l00535"></a>00535                                                         ToSendDataBuffer[3] = TRISC;
<a name="l00536"></a>00536                                                         ToSendDataBuffer[4] = TRISD;
<a name="l00537"></a>00537                                                         ToSendDataBuffer[5] = TRISE;
<a name="l00538"></a>00538                                                 <span class="keywordflow">break</span>;
<a name="l00539"></a>00539 
<a name="l00540"></a>00540                                                 <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#ce80ddb6d57fbd68150570e3fbe9caac" title="Demande l&amp;#39;état des ports du PIC.">GET_PORTS_STATE</a>:
<a name="l00541"></a>00541                                                         ToSendDataBuffer[1] = PORTA;
<a name="l00542"></a>00542                                                         ToSendDataBuffer[2] = PORTB;
<a name="l00543"></a>00543                                                         ToSendDataBuffer[3] = PORTC;
<a name="l00544"></a>00544                                                         ToSendDataBuffer[4] = PORTD;
<a name="l00545"></a>00545                                                         ToSendDataBuffer[5] = PORTE;
<a name="l00546"></a>00546                                                 <span class="keywordflow">break</span>;
<a name="l00547"></a>00547 
<a name="l00548"></a>00548                                                 <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#d91d480df9448cda096e31a8540c372c" title="Demande au PIC les valeurs des courants moteurs mesurées [Carte d&amp;#39;asservissement]...">GET_ISENS</a>:
<a name="l00549"></a>00549                                                         dword.<a class="code" href="union___d_w_o_r_d___v_a_l.html#4919f510dcac6be2acec24a14020a162">Val</a> = <a class="code" href="motor_8c.html#f28faafd0d5603bd1dfabbcd9731e0d9" title="Récupère la mesure du courant dans un moteur.">getIsens</a>(<a class="code" href="motor_8h.html#9eff471d17bc68f18b14ff75f23aa3bc" title="Sélection du moteur de droite (moteur 1).">MOTOR_RIGHT</a>);
<a name="l00550"></a>00550                                                         ToSendDataBuffer[1] = <a class="code" href="_generic_type_defs_8h.html#a014fb34c3bc2e52a76bdd3fbb079304">UPPER_MSB</a>(dword);
<a name="l00551"></a>00551                                                         ToSendDataBuffer[2] = <a class="code" href="_generic_type_defs_8h.html#1bcb16e2b1b950ca5d36f4d6c067f7b9">UPPER_LSB</a>(dword);
<a name="l00552"></a>00552                                                         ToSendDataBuffer[3] = <a class="code" href="_generic_type_defs_8h.html#7cc4e69f672bcde3cfef72e91de5042c">LOWER_MSB</a>(dword);
<a name="l00553"></a>00553                                                         ToSendDataBuffer[4] = <a class="code" href="_generic_type_defs_8h.html#4f415d5d850206edfda4411208f95780">LOWER_LSB</a>(dword);
<a name="l00554"></a>00554 
<a name="l00555"></a>00555                                                         dword.<a class="code" href="union___d_w_o_r_d___v_a_l.html#4919f510dcac6be2acec24a14020a162">Val</a> = <a class="code" href="motor_8c.html#f28faafd0d5603bd1dfabbcd9731e0d9" title="Récupère la mesure du courant dans un moteur.">getIsens</a>(<a class="code" href="motor_8h.html#0e2d750df9008232cafa398d2424b778" title="Sélection du moteur de gauche (moteur 2).">MOTOR_LEFT</a>);
<a name="l00556"></a>00556                                                         ToSendDataBuffer[5] = <a class="code" href="_generic_type_defs_8h.html#a014fb34c3bc2e52a76bdd3fbb079304">UPPER_MSB</a>(dword);
<a name="l00557"></a>00557                                                         ToSendDataBuffer[6] = <a class="code" href="_generic_type_defs_8h.html#1bcb16e2b1b950ca5d36f4d6c067f7b9">UPPER_LSB</a>(dword);
<a name="l00558"></a>00558                                                         ToSendDataBuffer[7] = <a class="code" href="_generic_type_defs_8h.html#7cc4e69f672bcde3cfef72e91de5042c">LOWER_MSB</a>(dword);
<a name="l00559"></a>00559                                                         ToSendDataBuffer[8] = <a class="code" href="_generic_type_defs_8h.html#4f415d5d850206edfda4411208f95780">LOWER_LSB</a>(dword);
<a name="l00560"></a>00560                                                 <span class="keywordflow">break</span>;
<a name="l00561"></a>00561 
<a name="l00562"></a>00562                                                 <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#f6e3c07112d6ecf73e4b87000f723ca1" title="Demande au PIC les positions actuelles des moteurs [Carte d&amp;#39;asservissement].">GET_CURRENT_POS</a>:
<a name="l00563"></a>00563                                                         <a class="code" href="lm629_8c.html#6fa7a38bcd0eeb3fb9c107702f73f516" title="Envoie une commande à/aux LM(s).">writeCommand</a>(<a class="code" href="motor_8h.html#9eff471d17bc68f18b14ff75f23aa3bc" title="Sélection du moteur de droite (moteur 1).">MOTOR_RIGHT</a>, <a class="code" href="lm629_8h.html#ff11a5c583c628c600f37c3aae47d181" title="Report -- Read Real Position.">LM_CMD_RDRP</a>);
<a name="l00564"></a>00564                                                         dword.<a class="code" href="union___d_w_o_r_d___v_a_l.html#a685f58ffe0cfd4f85e5cc18bb359827">word</a>.<a class="code" href="union___d_w_o_r_d___v_a_l.html#e329642eb1aff5886d2fe1bfc95e20ef">HW</a> = <a class="code" href="lm629_8c.html#ec750313f79234101e43e09e3083b947" title="Lire un mot envoyé par le LM (un mot = 2 octets = 16 bits).">readDataWord</a>(<a class="code" href="motor_8h.html#9eff471d17bc68f18b14ff75f23aa3bc" title="Sélection du moteur de droite (moteur 1).">MOTOR_RIGHT</a>);
<a name="l00565"></a>00565                                                         dword.<a class="code" href="union___d_w_o_r_d___v_a_l.html#a685f58ffe0cfd4f85e5cc18bb359827">word</a>.<a class="code" href="union___d_w_o_r_d___v_a_l.html#081f67fb9fb8b1148f3f7940638a73cd">LW</a> = <a class="code" href="lm629_8c.html#ec750313f79234101e43e09e3083b947" title="Lire un mot envoyé par le LM (un mot = 2 octets = 16 bits).">readDataWord</a>(<a class="code" href="motor_8h.html#9eff471d17bc68f18b14ff75f23aa3bc" title="Sélection du moteur de droite (moteur 1).">MOTOR_RIGHT</a>);
<a name="l00566"></a>00566 
<a name="l00567"></a>00567                                                         ToSendDataBuffer[1] = <a class="code" href="_generic_type_defs_8h.html#a014fb34c3bc2e52a76bdd3fbb079304">UPPER_MSB</a>(dword);
<a name="l00568"></a>00568                                                         ToSendDataBuffer[2] = <a class="code" href="_generic_type_defs_8h.html#1bcb16e2b1b950ca5d36f4d6c067f7b9">UPPER_LSB</a>(dword);
<a name="l00569"></a>00569                                                         ToSendDataBuffer[3] = <a class="code" href="_generic_type_defs_8h.html#7cc4e69f672bcde3cfef72e91de5042c">LOWER_MSB</a>(dword);
<a name="l00570"></a>00570                                                         ToSendDataBuffer[4] = <a class="code" href="_generic_type_defs_8h.html#4f415d5d850206edfda4411208f95780">LOWER_LSB</a>(dword);
<a name="l00571"></a>00571 
<a name="l00572"></a>00572                                                         <a class="code" href="lm629_8c.html#6fa7a38bcd0eeb3fb9c107702f73f516" title="Envoie une commande à/aux LM(s).">writeCommand</a>(<a class="code" href="motor_8h.html#0e2d750df9008232cafa398d2424b778" title="Sélection du moteur de gauche (moteur 2).">MOTOR_LEFT</a>, <a class="code" href="lm629_8h.html#ff11a5c583c628c600f37c3aae47d181" title="Report -- Read Real Position.">LM_CMD_RDRP</a>);
<a name="l00573"></a>00573                                                         dword.<a class="code" href="union___d_w_o_r_d___v_a_l.html#a685f58ffe0cfd4f85e5cc18bb359827">word</a>.<a class="code" href="union___d_w_o_r_d___v_a_l.html#e329642eb1aff5886d2fe1bfc95e20ef">HW</a> = <a class="code" href="lm629_8c.html#ec750313f79234101e43e09e3083b947" title="Lire un mot envoyé par le LM (un mot = 2 octets = 16 bits).">readDataWord</a>(<a class="code" href="motor_8h.html#0e2d750df9008232cafa398d2424b778" title="Sélection du moteur de gauche (moteur 2).">MOTOR_LEFT</a>);
<a name="l00574"></a>00574                                                         dword.<a class="code" href="union___d_w_o_r_d___v_a_l.html#a685f58ffe0cfd4f85e5cc18bb359827">word</a>.<a class="code" href="union___d_w_o_r_d___v_a_l.html#081f67fb9fb8b1148f3f7940638a73cd">LW</a> = <a class="code" href="lm629_8c.html#ec750313f79234101e43e09e3083b947" title="Lire un mot envoyé par le LM (un mot = 2 octets = 16 bits).">readDataWord</a>(<a class="code" href="motor_8h.html#0e2d750df9008232cafa398d2424b778" title="Sélection du moteur de gauche (moteur 2).">MOTOR_LEFT</a>);
<a name="l00575"></a>00575 
<a name="l00576"></a>00576                                                         ToSendDataBuffer[5] = <a class="code" href="_generic_type_defs_8h.html#a014fb34c3bc2e52a76bdd3fbb079304">UPPER_MSB</a>(dword);
<a name="l00577"></a>00577                                                         ToSendDataBuffer[6] = <a class="code" href="_generic_type_defs_8h.html#1bcb16e2b1b950ca5d36f4d6c067f7b9">UPPER_LSB</a>(dword);
<a name="l00578"></a>00578                                                         ToSendDataBuffer[7] = <a class="code" href="_generic_type_defs_8h.html#7cc4e69f672bcde3cfef72e91de5042c">LOWER_MSB</a>(dword);
<a name="l00579"></a>00579                                                         ToSendDataBuffer[8] = <a class="code" href="_generic_type_defs_8h.html#4f415d5d850206edfda4411208f95780">LOWER_LSB</a>(dword);
<a name="l00580"></a>00580                                                 <span class="keywordflow">break</span>;
<a name="l00581"></a>00581 
<a name="l00582"></a>00582                                                 <span class="keywordflow">default</span>:
<a name="l00583"></a>00583                                                         ToSendDataBuffer[1] = <a class="code" href="_pc_interface_8h.html#e950cf46a1155de5f6adfbdb614e0814" title="Demande inconnue.">ERR_UNKNOWN_GET</a>;
<a name="l00584"></a>00584                                         }
<a name="l00585"></a>00585 
<a name="l00586"></a>00586                                         <a class="code" href="main_8c.html#92264d29f54b522e280bcad0d603e64a">USBInHandle</a> = <a class="code" href="usb__function__hid_8h.html#83ec8b61af7d69c3e52fc9e92949764b">HIDTxPacket</a>(<a class="code" href="usb__config_8h.html#c4093f7479aadbd1a364d8caf7ac0fe7">HID_EP</a>, (<a class="code" href="_generic_type_defs_8h.html#4ae1dab0fb4b072a66584546209e7d58">BYTE</a>*) &amp;ToSendDataBuffer, 64);
<a name="l00587"></a>00587                                         <a class="code" href="main_8c.html#fdba80f833058ed3f3776089fe23821c">USBOutHandle</a> = <a class="code" href="usb__function__hid_8h.html#51903805a6cf95a33f689c5f95d9e915">HIDRxPacket</a>(<a class="code" href="usb__config_8h.html#c4093f7479aadbd1a364d8caf7ac0fe7">HID_EP</a>,(<a class="code" href="_generic_type_defs_8h.html#4ae1dab0fb4b072a66584546209e7d58">BYTE</a>*)&amp;<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>,64);               <span class="comment">// Re-arm the OUT endpoint for the next packet</span>
<a name="l00588"></a>00588                                 }
<a name="l00589"></a>00589                         <span class="keywordflow">break</span>;
<a name="l00590"></a>00590 
<a name="l00591"></a>00591                         <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#bb268d264836b9443ef23350814c0f68" title="Définir l&amp;#39;état d&amp;#39;un paramètre.">CMD_SET</a>:
<a name="l00592"></a>00592                                 <span class="keywordflow">switch</span> (<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[1]) {
<a name="l00593"></a>00593                                         <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#9671e443af58a672c1cac982aab3c217" title="Définir les entrées du PIC.">SET_PORTS_CONFIG_INPUTS</a>:
<a name="l00594"></a>00594                                                 TRISA|= <a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[2];
<a name="l00595"></a>00595                                                 TRISB|= <a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[3];
<a name="l00596"></a>00596                                                 TRISC|= <a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[4];
<a name="l00597"></a>00597                                                 TRISD|= <a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[5];
<a name="l00598"></a>00598                                                 TRISE|= <a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[6];
<a name="l00599"></a>00599                                         <span class="keywordflow">break</span>;
<a name="l00600"></a>00600 
<a name="l00601"></a>00601                                         <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#dc99d65115f431a881dd153a540ff00a" title="Définir les sorties du PIC.">SET_PORTS_CONFIG_OUTPUTS</a>:
<a name="l00602"></a>00602                                                 TRISA&amp;= ~<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[2];
<a name="l00603"></a>00603                                                 TRISB&amp;= ~<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[3];
<a name="l00604"></a>00604                                                 TRISC&amp;= ~<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[4];
<a name="l00605"></a>00605                                                 TRISD&amp;= ~<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[5];
<a name="l00606"></a>00606                                                 TRISE&amp;= ~<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[6];
<a name="l00607"></a>00607                                         <span class="keywordflow">break</span>;
<a name="l00608"></a>00608 
<a name="l00609"></a>00609                                         <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#4337af1b4705171921d322adc502d4db" title="Définir les sorties à l&amp;#39;état bas du PIC.">SET_PORTS_STATE_LOW</a>:
<a name="l00610"></a>00610                                                 LATA&amp;= ~<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[2];
<a name="l00611"></a>00611                                                 LATB&amp;= ~<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[3];
<a name="l00612"></a>00612                                                 LATC&amp;= ~<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[4];
<a name="l00613"></a>00613                                                 LATD&amp;= ~<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[5];
<a name="l00614"></a>00614                                                 LATE&amp;= ~<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[6];
<a name="l00615"></a>00615                                         <span class="keywordflow">break</span>;
<a name="l00616"></a>00616 
<a name="l00617"></a>00617                                         <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#802886de95962fcc1e851e2a8963dd7a" title="Définir les sorties à l&amp;#39;état haut du PIC.">SET_PORTS_STATE_HIGH</a>:
<a name="l00618"></a>00618                                                 LATA|= <a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[2];
<a name="l00619"></a>00619                                                 LATB|= <a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[3];
<a name="l00620"></a>00620                                                 LATC|= <a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[4];
<a name="l00621"></a>00621                                                 LATD|= <a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[5];
<a name="l00622"></a>00622                                                 LATE|= <a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[6];
<a name="l00623"></a>00623                                         <span class="keywordflow">break</span>;
<a name="l00624"></a>00624 
<a name="l00625"></a>00625                                         <span class="keywordflow">default</span>:
<a name="l00626"></a>00626                                         <span class="keywordflow">break</span>;
<a name="l00627"></a>00627                                 }
<a name="l00628"></a>00628 
<a name="l00629"></a>00629                                 <a class="code" href="main_8c.html#fdba80f833058ed3f3776089fe23821c">USBOutHandle</a> = <a class="code" href="usb__function__hid_8h.html#51903805a6cf95a33f689c5f95d9e915">HIDRxPacket</a>(<a class="code" href="usb__config_8h.html#c4093f7479aadbd1a364d8caf7ac0fe7">HID_EP</a>,(<a class="code" href="_generic_type_defs_8h.html#4ae1dab0fb4b072a66584546209e7d58">BYTE</a>*)&amp;<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>,64);               <span class="comment">// Re-arm the OUT endpoint for the next packet</span>
<a name="l00630"></a>00630                         <span class="keywordflow">break</span>;
<a name="l00631"></a>00631 
<a name="l00632"></a>00632                         <span class="keywordflow">case</span> <a class="code" href="_pc_interface_8h.html#a4853b407fdfe89d987756478ea51fef" title="Commande générique pour déclencher une action de test.">CMD_TEST</a>:
<a name="l00633"></a>00633                                 <span class="keywordflow">if</span> (!<a class="code" href="usb__function__hid_8h.html#1e12a1ffede90ef301604c507344c427">HIDTxHandleBusy</a>(<a class="code" href="main_8c.html#92264d29f54b522e280bcad0d603e64a">USBInHandle</a>)) {
<a name="l00634"></a>00634                                         state = 1;
<a name="l00635"></a>00635 
<a name="l00636"></a>00636                                         ToSendDataBuffer[0] = <a class="code" href="_pc_interface_8h.html#5e7e23f7dd514b640eddf3ac0c367f45" title="Envoyer du texte.">CMD_SEND</a>;
<a name="l00637"></a>00637                                         ToSendDataBuffer[1] = <span class="charliteral">'\0'</span>;
<a name="l00638"></a>00638                                         <a class="code" href="_compiler_8h.html#5e42f7bf7b2e4f4e8d9e79a02a3e0704">strcatpgm2ram</a>((<span class="keywordtype">char</span> *) &amp;ToSendDataBuffer[0], (<span class="keyword">const</span> rom far <span class="keywordtype">char</span> *) <span class="stringliteral">"Commande TEST reçue"</span>);
<a name="l00639"></a>00639 
<a name="l00640"></a>00640                                         <a class="code" href="main_8c.html#92264d29f54b522e280bcad0d603e64a">USBInHandle</a> = <a class="code" href="usb__function__hid_8h.html#83ec8b61af7d69c3e52fc9e92949764b">HIDTxPacket</a>(<a class="code" href="usb__config_8h.html#c4093f7479aadbd1a364d8caf7ac0fe7">HID_EP</a>, (<a class="code" href="_generic_type_defs_8h.html#4ae1dab0fb4b072a66584546209e7d58">BYTE</a>*) &amp;ToSendDataBuffer, 64);
<a name="l00641"></a>00641                                         <a class="code" href="main_8c.html#fdba80f833058ed3f3776089fe23821c">USBOutHandle</a> = <a class="code" href="usb__function__hid_8h.html#51903805a6cf95a33f689c5f95d9e915">HIDRxPacket</a>(<a class="code" href="usb__config_8h.html#c4093f7479aadbd1a364d8caf7ac0fe7">HID_EP</a>,(<a class="code" href="_generic_type_defs_8h.html#4ae1dab0fb4b072a66584546209e7d58">BYTE</a>*)&amp;<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>,64);               <span class="comment">// Re-arm the OUT endpoint for the next packet</span>
<a name="l00642"></a>00642                                 }
<a name="l00643"></a>00643                         <span class="keywordflow">break</span>;
<a name="l00644"></a>00644 
<a name="l00645"></a>00645                         <span class="keywordflow">default</span>:
<a name="l00646"></a>00646                                 <span class="comment">// Commande non reconnue</span>
<a name="l00647"></a>00647                                 <span class="keywordflow">if</span> (!<a class="code" href="usb__function__hid_8h.html#1e12a1ffede90ef301604c507344c427">HIDTxHandleBusy</a>(<a class="code" href="main_8c.html#92264d29f54b522e280bcad0d603e64a">USBInHandle</a>)) {
<a name="l00648"></a>00648                                         ToSendDataBuffer[0] = <a class="code" href="_pc_interface_8h.html#46fec82bccecfa46f11015c448c79fe7" title="Réponse à une commande.">CMD_RESPOND</a>;
<a name="l00649"></a>00649                                         ToSendDataBuffer[1] = <a class="code" href="_pc_interface_8h.html#ddfc7b504ad733cd1f4458751222e4a3" title="Commande inconnue.">ERR_UNKNOWN_CMD</a>;
<a name="l00650"></a>00650 
<a name="l00651"></a>00651                                         <a class="code" href="main_8c.html#92264d29f54b522e280bcad0d603e64a">USBInHandle</a> = <a class="code" href="usb__function__hid_8h.html#83ec8b61af7d69c3e52fc9e92949764b">HIDTxPacket</a>(<a class="code" href="usb__config_8h.html#c4093f7479aadbd1a364d8caf7ac0fe7">HID_EP</a>, (<a class="code" href="_generic_type_defs_8h.html#4ae1dab0fb4b072a66584546209e7d58">BYTE</a>*) &amp;ToSendDataBuffer, 64);
<a name="l00652"></a>00652                                         <a class="code" href="main_8c.html#fdba80f833058ed3f3776089fe23821c">USBOutHandle</a> = <a class="code" href="usb__function__hid_8h.html#51903805a6cf95a33f689c5f95d9e915">HIDRxPacket</a>(<a class="code" href="usb__config_8h.html#c4093f7479aadbd1a364d8caf7ac0fe7">HID_EP</a>,(<a class="code" href="_generic_type_defs_8h.html#4ae1dab0fb4b072a66584546209e7d58">BYTE</a>*)&amp;<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>,64);               <span class="comment">// Re-arm the OUT endpoint for the next packet</span>
<a name="l00653"></a>00653                                 }
<a name="l00654"></a>00654         }
<a name="l00655"></a>00655     }
<a name="l00656"></a>00656 }<span class="comment">//end ProcessIO</span>
</pre></div>
<p>

<p>
<div class="dynheader">
Voici le graphe d'appel pour cette fonction :</div>
<div class="dynsection">
<p><center><img src="main_8c_ace5bc936ba3a482762863d6da13c941_cgraph.png" border="0" usemap="#main_8c_ace5bc936ba3a482762863d6da13c941_cgraph_map" alt=""></center>
<map name="main_8c_ace5bc936ba3a482762863d6da13c941_cgraph_map">
<area shape="rect" href="main_8c.html#42a6b0f3c41a4e5e1722aca3c3a4b4b5" title="Gestion des LEDs selon l&#39;état du périphérique USB." alt="" coords="153,5,287,35"><area shape="rect" href="motor_8c.html#189f66fb3cf35d131837dd26974a3b8c" title="Active un ou plusieurs axe(s) moteur(s)." alt="" coords="165,59,275,88"><area shape="rect" href="motor_8c.html#f28faafd0d5603bd1dfabbcd9731e0d9" title="Récupère la mesure du courant dans un moteur." alt="" coords="179,112,261,141"><area shape="rect" href="lm629_8c.html#49e97890e5c9ab4f6fca2ba9ce33c885" title="Initialise les 2 LMs avec les paramètres par défaut." alt="" coords="184,269,256,299"><area shape="rect" href="lm629_8c.html#6fa7a38bcd0eeb3fb9c107702f73f516" title="Envoie une commande à/aux LM(s)." alt="" coords="687,321,815,351"><area shape="rect" href="lm629_8c.html#e3ef6f2f44349bc4e6af34671b6aa4aa" title="Lire un bit d&#39;état du LM." alt="" coords="344,68,461,97"><area shape="rect" href="lm629_8c.html#928f6fe98ffaaa8f72282688bcc8d1cd" title="Indique si la dernière trajectoire est terminée." alt="" coords="156,216,284,245"><area shape="rect" href="lm629_8c.html#f53f9dcb4f2401d3b013a07e63f8762d" title="Recule." alt="" coords="337,427,468,456"><area shape="rect" href="lm629_8c.html#bdba60aec4c9ae15e242fe1824ca4e5b" title="Avance." alt="" coords="343,373,463,403"><area shape="rect" href="lm629_8c.html#ec750313f79234101e43e09e3083b947" title="Lire un mot envoyé par le LM (un mot = 2 octets = 16 bits)." alt="" coords="687,428,815,457"><area shape="rect" href="eeprom_8c.html#23c79775828a6c484c66ba66b42ca847" title="Lit dans l&#39;EEPROM du PIC." alt="" coords="156,584,284,613"><area shape="rect" href="eeprom_8c.html#fd48dcf153304aa7a2726ca1b717ab14" title="Ecrit dans l&#39;EEPROM du PIC." alt="" coords="155,637,285,667"><area shape="rect" href="lm629_8c.html#18cecfad364f842e6a71efbd459857df" title="Initialise un LM, c&#39;est&#45;à&#45;dire :Contrôle que le RESET s&#39;est fait correctement..." alt="" coords="371,269,435,299"><area shape="rect" href="lm629_8c.html#87c455cfb4cbd87a3de45fd9f38a1b45" title="Lire l&#39;état d&#39;un LM." alt="" coords="701,183,800,212"><area shape="rect" href="lm629_8c.html#3917d5827bfa6cc17f4e1a47ff073248" title="Reset les bits d&#39;interruption du/des LM(s)." alt="" coords="519,373,636,403"><area shape="rect" href="lm629_8c.html#151178ea603ed04beaa1ba4151496878" title="Envoie un mot au LM (un mot = 2 octets = 16 bits)." alt="" coords="685,375,816,404"><area shape="rect" href="lm629_8c.html#6c314f24d23be4191ad86293c9a5fecc" title="Change la direction du BUS de donnée." alt="" coords="1021,324,1168,353"><area shape="rect" href="lm629_8c.html#89cbdf56bf6a423f871db85d9b25b7ba" title="Attends que le ou les LM(s) ne soient plus occupés." alt="" coords="865,324,972,353"><area shape="rect" href="lm629_8c.html#50cb02e459a813bf1d2d14a80d905a41" title="Programme une nouvelle position à atteindre." alt="" coords="524,480,631,509"><area shape="rect" href="lm629_8c.html#adb0186b6cbfbfe2f37d6e5d64284499" title="Démarre la trajectoire programmée." alt="" coords="552,427,603,456"></map>
</div>

</div>
</div><p>
<a class="anchor" name="d3060f9b061e802bba79e880c4484505"></a><!-- doxytag: member="main.c::ResetSource" ref="d3060f9b061e802bba79e880c4484505" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ResetSource           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="main_8c.html#d3060f9b061e802bba79e880c4484505" title="ResetSource() permet de connaitre l&#39;origine du dernier reset tout en réinitialisant...">ResetSource()</a> permet de connaitre l'origine du dernier reset tout en réinitialisant correctement les registres pour le prochain reset. 
<p>
Si elle n'est pas appelée à chaque démarrage du PIC, les registres ne seront pas correctement réinitialisées et l'origine du reset renvoyée par cette fonction pourra être erronée.<p>
<dl class="return" compact><dt><b>Renvoie:</b></dt><dd>source source du dernier RESET, peut valoir une des constantes RESET_*. </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l01018"></a>01018                        {
<a name="l01019"></a>01019         <span class="keywordtype">char</span> src;
<a name="l01020"></a>01020 
<a name="l01021"></a>01021         <span class="keywordflow">if</span> (!RCONbits.POR)
<a name="l01022"></a>01022                 <span class="comment">// Power-on Reset</span>
<a name="l01023"></a>01023                 src = <a class="code" href="_pc_interface_8h.html#524422e4fc9d394e0fd93b7c237f7a0d" title="Power-on Reset.">RESET_SOURCE_POR</a>;
<a name="l01024"></a>01024         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!RCONbits.RI)
<a name="l01025"></a>01025                 <span class="comment">// RESET Instruction</span>
<a name="l01026"></a>01026                 src = <a class="code" href="_pc_interface_8h.html#245ebb4ee7f1ea33154309bd1ed81f38" title="RESET Instruction.">RESET_SOURCE_RI</a>;
<a name="l01027"></a>01027         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!RCONbits.BOR) <span class="comment">// &amp;&amp; RCONbits.POR</span>
<a name="l01028"></a>01028                 <span class="comment">// Brown-out Reset</span>
<a name="l01029"></a>01029                 src = <a class="code" href="_pc_interface_8h.html#03a64d894da05e34b82b30d9ce329214" title="Brown-out Reset.">RESET_SOURCE_BOR</a>;
<a name="l01030"></a>01030         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!RCONbits.TO)
<a name="l01031"></a>01031                 <span class="comment">// Watchdog Time-out Reset</span>
<a name="l01032"></a>01032                 src = <a class="code" href="_pc_interface_8h.html#f12060aee7309d1d1c1ced73ee42bfdf" title="Watchdog Time-out Reset.">RESET_SOURCE_WDT</a>;
<a name="l01033"></a>01033         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (STKPTRbits.STKFUL)
<a name="l01034"></a>01034                 <span class="comment">// Stack Full Reset (STVREN = 1)</span>
<a name="l01035"></a>01035                 src = <a class="code" href="_pc_interface_8h.html#94baa8b4f808e0f4c6ca558f1e107e25" title="Stack Full Reset.">RESET_SOURCE_STKFUL</a>;
<a name="l01036"></a>01036         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (STKPTRbits.STKUNF)
<a name="l01037"></a>01037                 <span class="comment">// Stack Underflow Reset (STVREN = 1)</span>
<a name="l01038"></a>01038                 src = <a class="code" href="_pc_interface_8h.html#aed300e8316412f12e8f29cf667a391d" title="Stack Underflow Reset.">RESET_SOURCE_STKUNF</a>;
<a name="l01039"></a>01039         <span class="keywordflow">else</span>
<a name="l01040"></a>01040                 <span class="comment">// Master Clear Reset</span>
<a name="l01041"></a>01041                 src = <a class="code" href="_pc_interface_8h.html#39d66f0028a870a4ca903fdb417464f2" title="Master Clear Reset.">RESET_SOURCE_MCLR</a>;
<a name="l01042"></a>01042 
<a name="l01043"></a>01043         <span class="comment">// Réinitialisation de tous les bits de status</span>
<a name="l01044"></a>01044         RCONbits.RI = 1;
<a name="l01045"></a>01045         RCONbits.TO = 1;
<a name="l01046"></a>01046         RCONbits.PD = 1;
<a name="l01047"></a>01047         RCONbits.POR = 1;
<a name="l01048"></a>01048         RCONbits.BOR = 1;
<a name="l01049"></a>01049         STKPTRbits.STKFUL = 0;
<a name="l01050"></a>01050         STKPTRbits.STKUNF = 0;
<a name="l01051"></a>01051 
<a name="l01052"></a>01052         <span class="keywordflow">return</span> src;
<a name="l01053"></a>01053 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d39fa1008b49fb91555086e40710d573"></a><!-- doxytag: member="main.c::USBCB_SOF_Handler" ref="d39fa1008b49fb91555086e40710d573" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBCB_SOF_Handler           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The USB host sends out a SOF packet to full-speed devices every 1 ms. 
<p>
This interrupt may be useful for isochronous pipes. End designers should implement callback routine as necessary. <div class="fragment"><pre class="fragment"><a name="l00846"></a>00846 {
<a name="l00847"></a>00847     <span class="comment">// No need to clear UIRbits.SOFIF to 0 here.</span>
<a name="l00848"></a>00848     <span class="comment">// Callback caller is already doing that.</span>
<a name="l00849"></a>00849 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a1730f3cc119bd8eb04d9b55ebed56e6"></a><!-- doxytag: member="main.c::USBCBCheckOtherReq" ref="a1730f3cc119bd8eb04d9b55ebed56e6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBCBCheckOtherReq           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When SETUP packets arrive from the host, some firmware must process the request and respond appropriately to fulfill the request. 
<p>
Some of the SETUP packets will be for standard USB "chapter 9" (as in, fulfilling chapter 9 of the official USB specifications) requests, while others may be specific to the USB device class that is being implemented. For example, a HID class device needs to be able to respond to "GET REPORT" type of requests. This is not a standard USB chapter 9 request, and therefore not handled by <a class="el" href="usb__device_8c.html">usb_device.c</a>. Instead this request should be handled by class specific firmware, such as that contained in <a class="el" href="usb__function__hid_8c.html">usb_function_hid.c</a>. <div class="fragment"><pre class="fragment"><a name="l00896"></a>00896 {
<a name="l00897"></a>00897     <a class="code" href="usb__function__hid_8h.html#5e0b02add954ecf19bcdef679a58988b" title="Section: PUBLIC PROTOTYPES.">USBCheckHIDRequest</a>();
<a name="l00898"></a>00898 }<span class="comment">//end</span>
</pre></div>
<p>

<p>
<div class="dynheader">
Voici le graphe d'appel pour cette fonction :</div>
<div class="dynsection">
<p><center><img src="main_8c_a1730f3cc119bd8eb04d9b55ebed56e6_cgraph.png" border="0" usemap="#main_8c_a1730f3cc119bd8eb04d9b55ebed56e6_cgraph_map" alt=""></center>
<map name="main_8c_a1730f3cc119bd8eb04d9b55ebed56e6_cgraph_map">
<area shape="rect" href="usb__function__hid_8h.html#5e0b02add954ecf19bcdef679a58988b" title="Section: PUBLIC PROTOTYPES." alt="" coords="249,32,436,61"><area shape="rect" href="usb__function__hid_8c.html#fb60fd12cb265cc70fd3b2d11802cd09" title="PRIVATE PROTOTYPES." alt="" coords="485,5,664,35"><area shape="rect" href="usb__function__hid_8c.html#6d8be1c6f7f1a3ffb6c3b56ae1f067a6" title="HIDSetReportHandler" alt="" coords="487,59,663,88"></map>
</div>

</div>
</div><p>
<a class="anchor" name="e6717d77804b36ca26a975fd0bee6f01"></a><!-- doxytag: member="main.c::USBCBErrorHandler" ref="e6717d77804b36ca26a975fd0bee6f01" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBCBErrorHandler           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The purpose of this callback is mainly for debugging during development. 
<p>
Check UEIR to see which error causes the interrupt. <div class="fragment"><pre class="fragment"><a name="l00857"></a>00857 {
<a name="l00858"></a>00858     <span class="comment">// No need to clear UEIR to 0 here.</span>
<a name="l00859"></a>00859     <span class="comment">// Callback caller is already doing that.</span>
<a name="l00860"></a>00860 
<a name="l00861"></a>00861         <span class="comment">// Typically, user firmware does not need to do anything special</span>
<a name="l00862"></a>00862         <span class="comment">// if a USB error occurs.  For example, if the host sends an OUT</span>
<a name="l00863"></a>00863         <span class="comment">// packet to your device, but the packet gets corrupted (ex:</span>
<a name="l00864"></a>00864         <span class="comment">// because of a bad connection, or the user unplugs the</span>
<a name="l00865"></a>00865         <span class="comment">// USB cable during the transmission) this will typically set</span>
<a name="l00866"></a>00866         <span class="comment">// one or more USB error interrupt flags.  Nothing specific</span>
<a name="l00867"></a>00867         <span class="comment">// needs to be done however, since the SIE will automatically</span>
<a name="l00868"></a>00868         <span class="comment">// send a "NAK" packet to the host.  In response to this, the</span>
<a name="l00869"></a>00869         <span class="comment">// host will normally retry to send the packet again, and no</span>
<a name="l00870"></a>00870         <span class="comment">// data loss occurs.  The system will typically recover</span>
<a name="l00871"></a>00871         <span class="comment">// automatically, without the need for application firmware</span>
<a name="l00872"></a>00872         <span class="comment">// intervention.</span>
<a name="l00873"></a>00873         
<a name="l00874"></a>00874         <span class="comment">// Nevertheless, this callback function is provided, such as</span>
<a name="l00875"></a>00875         <span class="comment">// for debugging purposes.</span>
<a name="l00876"></a>00876 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e69da16b1f966a62cdd1831df5561cbf"></a><!-- doxytag: member="main.c::USBCBInitEP" ref="e69da16b1f966a62cdd1831df5561cbf" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBCBInitEP           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is called when the device becomes initialized, which occurs after the host sends a SET_CONFIGURATION (wValue not = 0) request. 
<p>
This callback function should initialize the endpoints for the device's usage according to the current configuration. <div class="fragment"><pre class="fragment"><a name="l00923"></a>00923 {
<a name="l00924"></a>00924     <span class="comment">//enable the HID endpoint</span>
<a name="l00925"></a>00925     <a class="code" href="usb__device_8h.html#25c6b82e249f563f00732a7e242c4267">USBEnableEndpoint</a>(<a class="code" href="usb__config_8h.html#c4093f7479aadbd1a364d8caf7ac0fe7">HID_EP</a>,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
<a name="l00926"></a>00926     <span class="comment">//Re-arm the OUT endpoint for the next packet</span>
<a name="l00927"></a>00927     <a class="code" href="main_8c.html#fdba80f833058ed3f3776089fe23821c">USBOutHandle</a> = <a class="code" href="usb__function__hid_8h.html#51903805a6cf95a33f689c5f95d9e915">HIDRxPacket</a>(<a class="code" href="usb__config_8h.html#c4093f7479aadbd1a364d8caf7ac0fe7">HID_EP</a>,(<a class="code" href="_generic_type_defs_8h.html#4ae1dab0fb4b072a66584546209e7d58">BYTE</a>*)&amp;<a class="code" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>,64);
<a name="l00928"></a>00928 }
</pre></div>
<p>

<p>
<div class="dynheader">
Voici le graphe d'appel pour cette fonction :</div>
<div class="dynsection">
<p><center><img src="main_8c_e69da16b1f966a62cdd1831df5561cbf_cgraph.png" border="0" usemap="#main_8c_e69da16b1f966a62cdd1831df5561cbf_cgraph_map" alt=""></center>
<map name="main_8c_e69da16b1f966a62cdd1831df5561cbf_cgraph_map">
<area shape="rect" href="usb__device_8h.html#25c6b82e249f563f00732a7e242c4267" title="USBEnableEndpoint" alt="" coords="176,5,344,35"><area shape="rect" href="usb__device_8h.html#1901fa27385226b6cdad1f5b091e5374" title="USBConfigureEndpoint" alt="" coords="393,5,583,35"></map>
</div>

</div>
</div><p>
<a class="anchor" name="0349054fd83e147e1a88e375748e8caf"></a><!-- doxytag: member="main.c::USBCBSendResume" ref="0349054fd83e147e1a88e375748e8caf" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBCBSendResume           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b></b></dt><dd>The USB specifications allow some types of USB peripheral devices to wake up a host PC (such as if it is in a low power suspend to RAM state). This can be a very useful feature in some USB applications, such as an Infrared remote control receiver. If a user presses the "power" button on a remote control, it is nice that the IR receiver can detect this signalling, and then send a USB "command" to the PC to wake up.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The <a class="el" href="usb__device_8h.html#0349054fd83e147e1a88e375748e8caf">USBCBSendResume()</a> "callback" function is used to send this special USB signalling which wakes up the PC. This function may be called by application firmware to wake up the PC. This function should only be called when:</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>1. The USB driver used on the host PC supports the remote wakeup capability. <br>
 2. The USB configuration descriptor indicates the device is remote wakeup capable in the bmAttributes field. <br>
 3. The USB host PC is currently sleeping, and has previously sent your device a SET FEATURE setup packet which "armed" the remote wakeup capability.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>This callback should send a RESUME signal that has the period of 1-15ms.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Interrupt vs. Polling <br>
 -Primary clock <br>
 -Secondary clock ***** MAKE NOTES ABOUT THIS ******* <br>
 &gt; Can switch to primary first by calling <a class="el" href="usb__device_8h.html#cb07fd7b59801b89093d5f5a375a1bb1" title="This function is called when the USB interrupt bit is set In this example the interrupt...">USBCBWakeFromSuspend()</a></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The modifiable section in this routine should be changed to meet the application needs. Current implementation temporary blocks other functions from executing for a period of 1-13 ms depending on the core frequency.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>According to USB 2.0 specification section 7.1.7.7, "The remote wakeup device must hold the resume signaling for at lest 1 ms but for no more than 15 ms." <br>
 The idea here is to use a delay counter loop, using a common value that would work over a wide range of core frequencies. <br>
 That value selected is 1800. See table below: <br>
 ========================================================== <br>
 Core Freq(MHz) MIP RESUME Signal Period (ms) <br>
 ========================================================== <br>
 48 12 1.05 <br>
 4 1 12.6 <br>
 ========================================================== <br>
 * These timing could be incorrect when using code optimization or extended instruction mode, or when having other interrupts enabled. Make sure to verify using the MPLAB SIM's Stopwatch and verify the actual signal on an oscilloscope. </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00996"></a>00996 {
<a name="l00997"></a>00997     <span class="keyword">static</span> <a class="code" href="_generic_type_defs_8h.html#2b0e863dadf920709ec53d9088ee7c91">WORD</a> delay_count;
<a name="l00998"></a>00998     
<a name="l00999"></a>00999     <a class="code" href="usb__hal__pic18_8h.html#2cbdeb8a88e95229eeb28b19a5e76a3b">USBResumeControl</a> = 1;                <span class="comment">// Start RESUME signaling</span>
<a name="l01000"></a>01000     
<a name="l01001"></a>01001     delay_count = 1800U;                <span class="comment">// Set RESUME line for 1-13 ms</span>
<a name="l01002"></a>01002     <span class="keywordflow">do</span>
<a name="l01003"></a>01003     {
<a name="l01004"></a>01004         delay_count--;
<a name="l01005"></a>01005     }<span class="keywordflow">while</span>(delay_count);
<a name="l01006"></a>01006     <a class="code" href="usb__hal__pic18_8h.html#2cbdeb8a88e95229eeb28b19a5e76a3b">USBResumeControl</a> = 0;
<a name="l01007"></a>01007 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="85c176c4ca674eb30b43b414f6a66260"></a><!-- doxytag: member="main.c::USBCBStdSetDscHandler" ref="85c176c4ca674eb30b43b414f6a66260" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBCBStdSetDscHandler           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <a class="el" href="usb__device_8h.html#85c176c4ca674eb30b43b414f6a66260" title="The USBCBStdSetDscHandler() callback function is called when a SETUP, bRequest: SET_DESCRIPTOR...">USBCBStdSetDscHandler()</a> callback function is called when a SETUP, bRequest: SET_DESCRIPTOR request arrives. 
<p>
Typically SET_DESCRIPTOR requests are not used in most applications, and it is optional to support this type of request. <div class="fragment"><pre class="fragment"><a name="l00909"></a>00909 {
<a name="l00910"></a>00910     <span class="comment">// Must claim session ownership if supporting this request</span>
<a name="l00911"></a>00911 }<span class="comment">//end</span>
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="24bc7f902cfd3ef505708c71099ca32a"></a><!-- doxytag: member="main.c::USBCBSuspend" ref="24bc7f902cfd3ef505708c71099ca32a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBCBSuspend           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call back that is invoked when a USB suspend is detected. 
<p>
Section: CALLBACKS. <div class="fragment"><pre class="fragment"><a name="l00760"></a>00760 {
<a name="l00761"></a>00761         <span class="comment">//Example power saving code.  Insert appropriate code here for the desired</span>
<a name="l00762"></a>00762         <span class="comment">//application behavior.  If the microcontroller will be put to sleep, a</span>
<a name="l00763"></a>00763         <span class="comment">//process similar to that shown below may be used:</span>
<a name="l00764"></a>00764         
<a name="l00765"></a>00765         <span class="comment">//ConfigureIOPinsForLowPower();</span>
<a name="l00766"></a>00766         <span class="comment">//SaveStateOfAllInterruptEnableBits();</span>
<a name="l00767"></a>00767         <span class="comment">//DisableAllInterruptEnableBits();</span>
<a name="l00768"></a>00768         <span class="comment">//EnableOnlyTheInterruptsWhichWillBeUsedToWakeTheMicro();       //should enable at least USBActivityIF as a wake source</span>
<a name="l00769"></a>00769         <span class="comment">//Sleep();</span>
<a name="l00770"></a>00770         <span class="comment">//RestoreStateOfAllPreviouslySavedInterruptEnableBits();        //Preferrably, this should be done in the USBCBWakeFromSuspend() function instead.</span>
<a name="l00771"></a>00771         <span class="comment">//RestoreIOPinsToNormal();                                                                      //Preferrably, this should be done in the USBCBWakeFromSuspend() function instead.</span>
<a name="l00772"></a>00772 
<a name="l00773"></a>00773         <span class="comment">//IMPORTANT NOTE: Do not clear the USBActivityIF (ACTVIF) bit here.  This bit is </span>
<a name="l00774"></a>00774         <span class="comment">//cleared inside the usb_device.c file.  Clearing USBActivityIF here will cause </span>
<a name="l00775"></a>00775         <span class="comment">//things to not work as intended.       </span>
<a name="l00776"></a>00776 
<a name="l00777"></a>00777 <span class="preprocessor">    #if defined(__C30__)</span>
<a name="l00778"></a>00778 <span class="preprocessor"></span><span class="preprocessor">    #if 0</span>
<a name="l00779"></a>00779 <span class="preprocessor"></span>        <a class="code" href="usb__hal__pic18_8h.html#ba77d553dab6b24f442c2415b48d93e7">U1EIR</a> = 0xFFFF;
<a name="l00780"></a>00780         <a class="code" href="usb__hal__pic18_8h.html#dcc39d6045679c6ea0af970ae03e3b32">U1IR</a> = 0xFFFF;
<a name="l00781"></a>00781         U1OTGIR = 0xFFFF;
<a name="l00782"></a>00782         IFS5bits.USB1IF = 0;
<a name="l00783"></a>00783         IEC5bits.USB1IE = 1;
<a name="l00784"></a>00784         U1OTGIEbits.ACTVIE = 1;
<a name="l00785"></a>00785         U1OTGIRbits.ACTVIF = 1;
<a name="l00786"></a>00786         TRISA &amp;= 0xFF3F;
<a name="l00787"></a>00787         LATAbits.LATA6 = 1;
<a name="l00788"></a>00788         Sleep();
<a name="l00789"></a>00789         LATAbits.LATA6 = 0;
<a name="l00790"></a>00790 <span class="preprocessor">    #endif</span>
<a name="l00791"></a>00791 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00792"></a>00792 <span class="preprocessor"></span>}
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="cb07fd7b59801b89093d5f5a375a1bb1"></a><!-- doxytag: member="main.c::USBCBWakeFromSuspend" ref="cb07fd7b59801b89093d5f5a375a1bb1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBCBWakeFromSuspend           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is called when the USB interrupt bit is set In this example the interrupt is only used when the device goes to sleep when it receives a USB suspend command. 
<p>
The host may put USB peripheral devices in low power suspend mode (by "sending" 3+ms of idle). Once in suspend mode, the host may wake the device back up by sending non- idle state signalling. <br>
 This call back is invoked when a wakeup from USB suspend is detected. <div class="fragment"><pre class="fragment"><a name="l00828"></a>00828 {
<a name="l00829"></a>00829         <span class="comment">// If clock switching or other power savings measures were taken when</span>
<a name="l00830"></a>00830         <span class="comment">// executing the USBCBSuspend() function, now would be a good time to</span>
<a name="l00831"></a>00831         <span class="comment">// switch back to normal full power run mode conditions.  The host allows</span>
<a name="l00832"></a>00832         <span class="comment">// a few milliseconds of wakeup time, after which the device must be </span>
<a name="l00833"></a>00833         <span class="comment">// fully back to normal, and capable of receiving and processing USB</span>
<a name="l00834"></a>00834         <span class="comment">// packets.  In order to do this, the USB module must receive proper</span>
<a name="l00835"></a>00835         <span class="comment">// clocking (IE: 48MHz clock must be available to SIE for full speed USB</span>
<a name="l00836"></a>00836         <span class="comment">// operation).</span>
<a name="l00837"></a>00837 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="655d748c28aad5b529f5826b50fe1251"></a><!-- doxytag: member="main.c::UserInit" ref="655d748c28aad5b529f5826b50fe1251" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UserInit           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Routine d'initialisation utilisateur. 
<p>
C'est dans cette fonction que sont centralisées toutes les initialisations du PIC, hormis pour l'USB. <dl class="see" compact><dt><b>Voir également:</b></dt><dd><a class="el" href="main_8c.html#4f80a71f6079faf7617114a373a05017" title="Centralise les routines d&#39;initialisation.">InitializeSystem()</a> </dd></dl>

<p>
Initialisation des composants externes <div class="fragment"><pre class="fragment"><a name="l00373"></a>00373 {
<a name="l00374"></a>00374         <span class="comment">// ResetSource() permet de connaitre l'origine du dernier reset tout en réinitialisant correctement</span>
<a name="l00375"></a>00375         <span class="comment">// les registres pour le prochain reset. Si elle n'est pas appelée à chaque démarrage du PIC, les</span>
<a name="l00376"></a>00376         <span class="comment">// registres ne seront pas correctement réinitialisées et l'origine du reset renvoyée par cette</span>
<a name="l00377"></a>00377         <span class="comment">// fonction pourra être erronée.</span>
<a name="l00378"></a>00378         <a class="code" href="main_8c.html#d1e58a5c30aa93b2b02ed582dc185fa5">resetSource</a> = <a class="code" href="main_8c.html#d3060f9b061e802bba79e880c4484505" title="ResetSource() permet de connaitre l&amp;#39;origine du dernier reset tout en réinitialisant...">ResetSource</a>();
<a name="l00379"></a>00379 
<a name="l00380"></a>00380         <span class="comment">// Configuration interruptions</span>
<a name="l00381"></a>00381         RCONbits.IPEN = 1;              <span class="comment">// Enable priority levels on interrupts</span>
<a name="l00382"></a>00382         INTCONbits.GIE = 1;             <span class="comment">// Enables all high priority interrupts</span>
<a name="l00383"></a>00383         INTCONbits.PEIE = 1;    <span class="comment">// Enables all low priority peripheral interrupts</span>
<a name="l00384"></a>00384 
<a name="l00385"></a>00385         <span class="comment">// Configuration de l'I2C</span>
<a name="l00386"></a>00386 <span class="comment">//      OpenI2C(MASTER, SLEW_OFF);</span>
<a name="l00387"></a>00387 
<a name="l00392"></a>00392     <span class="comment">//Initialize all of the LED pins</span>
<a name="l00393"></a>00393     <a class="code" href="_hardware_profile_8h.html#27e6bd4d852b6452a2aeadd96df5139e" title="LED.">mInitAllLEDs</a>();
<a name="l00394"></a>00394 
<a name="l00395"></a>00395     <span class="comment">//initialize the variable holding the handle for the last</span>
<a name="l00396"></a>00396     <span class="comment">// transmission</span>
<a name="l00397"></a>00397     <a class="code" href="main_8c.html#fdba80f833058ed3f3776089fe23821c">USBOutHandle</a> = 0;
<a name="l00398"></a>00398     <a class="code" href="main_8c.html#92264d29f54b522e280bcad0d603e64a">USBInHandle</a> = 0;
<a name="l00399"></a>00399 
<a name="l00400"></a>00400     <a class="code" href="main_8c.html#663117df30d6ab9eef2e1280f4956ec3">blinkStatusValid</a> = <a class="code" href="_generic_type_defs_8h.html#fbf708854fe02af8475a9ba02f3196cba82764c3079aea4e60c80e45befbb839">TRUE</a>;
<a name="l00401"></a>00401 
<a name="l00402"></a>00402         <span class="comment">// Asservissement</span>
<a name="l00403"></a>00403         <a class="code" href="motor_8h.html#8a878d2e3b31dfd8c15559651852d37d" title="Initialise l&amp;#39;interface de commande des cartes de puissance.">initMotors</a>();   <span class="comment">// après initialisation des moteurs, il faut attendre un certain temps </span>
<a name="l00404"></a>00404                                         <span class="comment">// avant de débuter une trajectoire (temps d'initialisation du driver HIP4081)</span>
<a name="l00405"></a>00405         <a class="code" href="lm629_8h.html#cf8771cb148de16a0af5369f8288204b" title="Initialise l&amp;#39;interface entre le PIC et les LM629 puis effectue un RESET des LM629...">initBoard</a>();    <span class="comment">// idem ici, compter 1.5 ms avant que les LMs soient prêts</span>
<a name="l00406"></a>00406 
<a name="l00407"></a>00407         <span class="comment">// Configuration du timer1</span>
<a name="l00408"></a>00408         PIE1bits.TMR1IE = 1;    <span class="comment">// Autorise les interruption par dépassement du Timer (Timer overflow)</span>
<a name="l00409"></a>00409         OpenTimer1(TIMER_INT_ON         <span class="comment">// active le timer1</span>
<a name="l00410"></a>00410                  &amp; T1_16BIT_RW                  <span class="comment">// compte sur 16 bits</span>
<a name="l00411"></a>00411                  &amp; T1_SOURCE_INT                <span class="comment">// utilise l'horloge interne</span>
<a name="l00412"></a>00412                  &amp; T1_PS_1_1                    <span class="comment">// incrémente le compteur à chaque cycle (1:1)</span>
<a name="l00413"></a>00413                  &amp; T1_OSC1EN_OFF                <span class="comment">// pas d'oscillateur sur le timer1</span>
<a name="l00414"></a>00414                  &amp; T1_SYNC_EXT_OFF              <span class="comment">// ne pas se synchroniser sur une horloge externe</span>
<a name="l00415"></a>00415         );
<a name="l00416"></a>00416         WriteTimer1(57536); <span class="comment">// 2^16 - 8 000 : la prochaine interruption a lieu dans 8 000 cycles = 1 ms</span>
<a name="l00417"></a>00417 
<a name="l00418"></a>00418 }<span class="comment">//end UserInit</span>
</pre></div>
<p>

<p>
<div class="dynheader">
Voici le graphe d'appel pour cette fonction :</div>
<div class="dynsection">
<p><center><img src="main_8c_655d748c28aad5b529f5826b50fe1251_cgraph.png" border="0" usemap="#main_8c_655d748c28aad5b529f5826b50fe1251_cgraph_map" alt=""></center>
<map name="main_8c_655d748c28aad5b529f5826b50fe1251_cgraph_map">
<area shape="rect" href="main_8c.html#d3060f9b061e802bba79e880c4484505" title="ResetSource() permet de connaitre l&#39;origine du dernier reset tout en réinitialisant..." alt="" coords="132,5,247,35"></map>
</div>

</div>
</div><p>
<a class="anchor" name="6647fa4207d49c8ba30d1609d0554791"></a><!-- doxytag: member="main.c::YourHighPriorityISRCode" ref="6647fa4207d49c8ba30d1609d0554791" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void YourHighPriorityISRCode           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8fc705d66a5ec3a6012cd0d4210ac8a9"></a><!-- doxytag: member="main.c::YourLowPriorityISRCode" ref="8fc705d66a5ec3a6012cd0d4210ac8a9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void YourLowPriorityISRCode           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Documentation des variables</h2>
<a class="anchor" name="663117df30d6ab9eef2e1280f4956ec3"></a><!-- doxytag: member="main.c::blinkStatusValid" ref="663117df30d6ab9eef2e1280f4956ec3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_generic_type_defs_8h.html#54d65c7fa62e62c9754371e42f5111b9">BOOL</a> <a class="el" href="main_8c.html#663117df30d6ab9eef2e1280f4956ec3">blinkStatusValid</a> = TRUE          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b4ee221e7a47440a79c5453a24ae8631"></a><!-- doxytag: member="main.c::ms" ref="b4ee221e7a47440a79c5453a24ae8631" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile unsigned int <a class="el" href="main_8c.html#b4ee221e7a47440a79c5453a24ae8631">ms</a> = 0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6d79583150d44af3d64e01a6c4e3abe0"></a><!-- doxytag: member="main.c::ReceivedDataBuffer" ref="6d79583150d44af3d64e01a6c4e3abe0" args="[64]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char <a class="el" href="main_8c.html#6d79583150d44af3d64e01a6c4e3abe0">ReceivedDataBuffer</a>[64]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="d1e58a5c30aa93b2b02ed582dc185fa5"></a><!-- doxytag: member="main.c::resetSource" ref="d1e58a5c30aa93b2b02ed582dc185fa5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="main_8c.html#d1e58a5c30aa93b2b02ed582dc185fa5">resetSource</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1ac96063dd8d639a297e0b06a32180fe"></a><!-- doxytag: member="main.c::s" ref="1ac96063dd8d639a297e0b06a32180fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile unsigned int <a class="el" href="main_8c.html#1ac96063dd8d639a297e0b06a32180fe">s</a> = 0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="cdc91cb16e31f2cb52e08df9cdf00b72"></a><!-- doxytag: member="main.c::ToSendDataBuffer" ref="cdc91cb16e31f2cb52e08df9cdf00b72" args="[64]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char <a class="el" href="main_8c.html#cdc91cb16e31f2cb52e08df9cdf00b72">ToSendDataBuffer</a>[64]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="92264d29f54b522e280bcad0d603e64a"></a><!-- doxytag: member="main.c::USBInHandle" ref="92264d29f54b522e280bcad0d603e64a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USB_HANDLE <a class="el" href="main_8c.html#92264d29f54b522e280bcad0d603e64a">USBInHandle</a> = 0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="fdba80f833058ed3f3776089fe23821c"></a><!-- doxytag: member="main.c::USBOutHandle" ref="fdba80f833058ed3f3776089fe23821c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USB_HANDLE <a class="el" href="main_8c.html#fdba80f833058ed3f3776089fe23821c">USBOutHandle</a> = 0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Généré le Sat Feb 14 20:04:57 2009 pour Carte d'asservissement (bi) par&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
